<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>快速地改善代码质量的20条编程规范</title>
      <link href="/2023/02/05/%E5%BF%AB%E9%80%9F%E5%9C%B0%E6%94%B9%E5%96%84%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%8420%E6%9D%A1%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
      <url>/2023/02/05/%E5%BF%AB%E9%80%9F%E5%9C%B0%E6%94%B9%E5%96%84%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%8420%E6%9D%A1%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最应该关注、最好用的编码规范，分为三个大的方面：命名与注释（Naming and Comments）、代码风格（Code Style）、编程技巧（Coding Tips）。</p></blockquote><h1 id="命名与注释（Naming-and-Comments）"><a href="#命名与注释（Naming-and-Comments）" class="headerlink" title="命名与注释（Naming and Comments）"></a>命名与注释（Naming and Comments）</h1><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><h3 id="1-命名多长最合适？"><a href="#1-命名多长最合适？" class="headerlink" title="1. 命名多长最合适？"></a>1. 命名多长最合适？</h3><p>实际上，在足够表达其含义的情况下，命名当然是越短越好。</p><p>对于一些默认的、大家都比较熟知的词，我比较推荐用缩写。这样一方面能让命名短一些，另一方面又不影响阅读理解，比如，sec 表示 second、str 表示 string、num 表示 number、doc 表示 document。</p><p>除此之外，对于作用域比较小的变量，我们可以使用相对短的命名，比如一些函数内的临时变量。相反，对于类名这种作用域比较大的，我更推荐用长的命名方式。</p><p><strong>总之，命名的一个原则就是以能准确达意为目标。</strong></p><h3 id="2-利用上下文简化命名"><a href="#2-利用上下文简化命名" class="headerlink" title="2. 利用上下文简化命名"></a>2. 利用上下文简化命名</h3><pre><code class="java">public class User &#123;  private String userName;  private String userPassword;  private String userAvatarUrl;  //...&#125;</code></pre><p>在 User 类这样一个上下文中，我们没有在成员变量的命名中重复添加“user”这样一个前缀单词，而是直接命名为 name、password、avatarUrl</p><h3 id="3-命名要可读、可搜索"><a href="#3-命名要可读、可搜索" class="headerlink" title="3. 命名要可读、可搜索"></a>3. 命名要可读、可搜索</h3><p>首先，我们来看，什么是命名可读。先解释一下，我这里所说的“可读”，指的是<strong>不要用一些特别生僻、难发音的英文单词来命名</strong>。</p><p>我们再来讲一下命名可搜索。我们在 IDE 中编写代码的时候，经常会用<strong>“关键词联想”的方法来自动补全和搜索</strong>。</p><h3 id="4-如何命名接口和抽象类？"><a href="#4-如何命名接口和抽象类？" class="headerlink" title="4. 如何命名接口和抽象类？"></a>4. 如何命名接口和抽象类？</h3><p>对于<strong>接口的命名</strong>，一般有两种比较常见的方式。一种是加<strong>前缀“I”</strong>，表示一个 Interface。比如 IUserService，对应的实现类命名为 UserService。另一种是不加前缀，比如 UserService，对应的实现类加后缀“Impl”，比如 UserServiceImpl。</p><p>对于<strong>抽象类的命名</strong>，也有两种方式，一种是带上<strong>前缀“Abstract”</strong>，比如 AbstractConfiguration；另一种是不带前缀“Abstract”。实际上，对于接口和抽象类，选择哪种命名方式都是可以的，只要项目里能够统一就行。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="1-注释到底该写什么？"><a href="#1-注释到底该写什么？" class="headerlink" title="1. 注释到底该写什么？"></a>1. 注释到底该写什么？</h3><p>注释的目的就是让代码更容易看懂。只要符合这个要求的内容，你就可以将它写到注释里。总结一下，注释的内容主要包含这样三个方面：做什么、为什么、怎么做。</p><pre><code class="java">/*** (what) Bean factory to create beans. * * (why) The class likes Spring IOC framework, but is more lightweight. ** (how) Create objects from different sources sequentially:* user specified object &gt; SPI &gt; configuration &gt; default object.*/public class BeansFactory &#123;  // ...&#125;</code></pre><ul><li>注释比代码承载的信息更多</li><li>注释起到总结性作用、文档的作用</li><li>一些总结性注释能让代码结构更清晰</li></ul><h3 id="2-注释是不是越多越好？"><a href="#2-注释是不是越多越好？" class="headerlink" title="2. 注释是不是越多越好？"></a>2. 注释是不是越多越好？</h3><p>注释太多和太少都有问题。太多，有可能意味着代码写得不够可读，需要写很多注释来补充。</p><p>按照我的经验来说，<strong>类和函数一定要写注释，而且要写得尽可能全面、详细</strong>，而函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码的可读性。</p><h1 id="代码风格（Code-Style）"><a href="#代码风格（Code-Style）" class="headerlink" title="代码风格（Code Style）"></a>代码风格（Code Style）</h1><h2 id="1-类、函数多大才合适？"><a href="#1-类、函数多大才合适？" class="headerlink" title="1. 类、函数多大才合适？"></a>1. 类、函数多大才合适？</h2><p>总体上来讲，类或函数的代码行数不能太多，但也不能太少。</p><p>那一个类或函数有多少行代码才最合适呢？</p><p>对于函数代码行数的最大限制，网上有一种说法，那就是<strong>不要超过一个显示屏的垂直高度</strong>。</p><p>对于类的代码行数的最大限制，这个就更难给出一个确切的值了。</p><p>当一个类的代码读起来让你感觉头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能要引入整个类（类中包含很多无关此功能实现的函数）的时候，这就说明类的行数过多了。</p><h2 id="2-一行代码多长最合适？"><a href="#2-一行代码多长最合适？" class="headerlink" title="2. 一行代码多长最合适？"></a>2. 一行代码多长最合适？</h2><p>在Google Java Style Guide文档中，一行代码最长限制为 100 个字符。</p><p>不管这个限制是多少，总体上来讲我们要遵循的一个原则是：<strong>一行代码最长不能超过 IDE 显示的宽度</strong>。需要滚动鼠标才能查看一行的全部代码，显然不利于代码的阅读。</p><h2 id="3-善用空行分割单元块"><a href="#3-善用空行分割单元块" class="headerlink" title="3. 善用空行分割单元块"></a>3. 善用空行分割单元块</h2><p>对于比较长的函数，如果逻辑上可以分为几个独立的代码块，在不方便将这些独立的代码块抽取成小函数的情况下，为了让逻辑更加清晰，除了上一节课中提到的用总结性注释的方法之外，我们还可以使用空行来分割各个代码块。</p><p>除此之外，在类的成员变量与函数之间、静态成员变量与普通成员变量之间、各函数之间、甚至各成员变量之间，我们都可以<strong>通过添加空行的方式，让这些不同模块的代码之间，界限更加明确。</strong></p><h2 id="4-四格缩进还是两格缩进？"><a href="#4-四格缩进还是两格缩进？" class="headerlink" title="4. 四格缩进还是两格缩进？"></a>4. 四格缩进还是两格缩进？</h2><p>据我所知，Java 语言倾向于两格缩进，PHP 语言倾向于四格缩进。至于到底应该是两格缩进还是四格缩进，我觉得这个取决于个人喜好。只要项目内部能够统一就行了。</p><p>当然，还有一个选择的标准，那就是跟业内推荐的风格统一、跟著名开源项目统一。</p><p>除此之外，值得强调的是，<strong>不管是用两格缩进还是四格缩进，一定不要用 tab 键缩进</strong>。因为在不同的 IDE 下，tab 键的显示宽度不同，有的显示为四格缩进，有的显示为两格缩进。</p><h2 id="5-大括号是否要另起一行？"><a href="#5-大括号是否要另起一行？" class="headerlink" title="5. 大括号是否要另起一行？"></a>5. 大括号是否要另起一行？</h2><p>左大括号是否要另起一行呢？这个也有争论。据我所知，PHP 程序员喜欢另起一行，Java 程序员喜欢跟上一条语句放到一起。</p><p>我个人还是比较推荐，将括号放到跟语句同一行的风格。理由跟上面类似，节省代码行数。</p><h2 id="6-类中成员的排列顺序"><a href="#6-类中成员的排列顺序" class="headerlink" title="6. 类中成员的排列顺序"></a>6. 类中成员的排列顺序</h2><p>在 Java 类文件中，先要书写类所属的包名，然后再罗列 import 引入的依赖类。<strong>在 Google 编码规范中，依赖类按照字母序从小到大排列。</strong></p><p>在类中，成员变量排在函数的前面。成员变量之间或函数之间，都是按照“先静态（静态函数或静态成员变量）、后普通（非静态函数或非静态成员变量）”的方式来排列的。</p><p>除此之外，成员变量之间或函数之间，还会按照作用域范围从大到小的顺序来排列，先写 public 成员变量或函数，然后是 protected 的，最后是 private 的。</p><p>实际上，还有另外一种排列习惯，那就是把有调用关系的函数放到一块。比如，一个 public 函数调用了另外一个 private 函数，那就把这两者放到一块。</p><h1 id="编程技巧（Coding-Tips）"><a href="#编程技巧（Coding-Tips）" class="headerlink" title="编程技巧（Coding Tips）"></a>编程技巧（Coding Tips）</h1><h2 id="1-把代码分割成更小的单元块"><a href="#1-把代码分割成更小的单元块" class="headerlink" title="1. 把代码分割成更小的单元块"></a>1. 把代码分割成更小的单元块</h2><p>大部分人阅读代码的习惯都是，先看整体再看细节。所以，我们要有模块化和抽象思维，善于将大块的复杂逻辑提炼成类或者函数，屏蔽掉细节，让阅读代码的人不至于迷失在细节中，这样能极大地提高代码的可读性。</p><h2 id="2-避免函数参数过多"><a href="#2-避免函数参数过多" class="headerlink" title="2. 避免函数参数过多"></a>2. 避免函数参数过多</h2><p>我个人觉得，函数包含 3、4 个参数的时候还是能接受的，大于等于 5 个的时候，我们就觉得参数有点过多了，会影响到代码的可读性，使用起来也不方便。</p><ul><li>考虑函数是否职责单一，是否能通过拆分成多个函数的方式来减少参数。示例代码如下所示：</li></ul><pre><code class="java">public User getUser(String username, String telephone, String email);// 拆分成多个函数public User getUserByUsername(String username);public User getUserByTelephone(String telephone);public User getUserByEmail(String email);</code></pre><ul><li>将函数的参数封装成对象。示例代码如下所示：</li></ul><pre><code class="java">public void postBlog(String title, String summary, String keywords, String content, String category, long authorId);// 将参数封装成对象public class Blog &#123;  private String title;  private String summary;  private String keywords;  private Strint content;  private String category;  private long authorId;&#125;public void postBlog(Blog blog);</code></pre><p>除此之外，如果函数是对外暴露的远程接口，将参数封装成对象，还可以提高接口的兼容性。在往接口中添加新的参数的时候，老的远程接口调用者有可能就不需要修改代码来兼容新的接口了。</p><h2 id="3-勿用函数参数来控制逻辑"><a href="#3-勿用函数参数来控制逻辑" class="headerlink" title="3. 勿用函数参数来控制逻辑"></a>3. 勿用函数参数来控制逻辑</h2><p>不要在函数中使用布尔类型的标识参数来控制内部逻辑，true 的时候走这块逻辑，false 的时候走另一块逻辑。这明显违背了单一职责原则和接口隔离原则。我建议将其拆成两个函数，可读性上也要更好。</p><pre><code class="java">public void buyCourse(long userId, long courseId, boolean isVip);// 将其拆分成两个函数public void buyCourse(long userId, long courseId);public void buyCourseForVip(long userId, long courseId);</code></pre><p>不过，如果函数是 private 私有函数，影响范围有限，或者拆分之后的两个函数经常同时被调用，我们可以酌情考虑保留标识参数。</p><p>除了布尔类型作为标识参数来控制逻辑的情况外，还有一种“根据参数是否为 null”来控制逻辑的情况。针对这种情况，我们也应该将其拆分成多个函数。拆分之后的函数职责更明确，不容易用错。</p><pre><code class="java">public List&lt;Transaction&gt; selectTransactions(Long userId, Date startDate, Date endDate) &#123;  if (startDate != null &amp;&amp; endDate != null) &#123;    // 查询两个时间区间的transactions  &#125;  if (startDate != null &amp;&amp; endDate == null) &#123;    // 查询startDate之后的所有transactions  &#125;  if (startDate == null &amp;&amp; endDate != null) &#123;    // 查询endDate之前的所有transactions  &#125;  if (startDate == null &amp;&amp; endDate == null) &#123;    // 查询所有的transactions  &#125;&#125;// 拆分成多个public函数，更加清晰、易用public List&lt;Transaction&gt; selectTransactionsBetween(Long userId, Date startDate, Date endDate) &#123;  return selectTransactions(userId, startDate, endDate);&#125;public List&lt;Transaction&gt; selectTransactionsStartWith(Long userId, Date startDate) &#123;  return selectTransactions(userId, startDate, null);&#125;public List&lt;Transaction&gt; selectTransactionsEndWith(Long userId, Date endDate) &#123;  return selectTransactions(userId, null, endDate);&#125;public List&lt;Transaction&gt; selectAllTransactions(Long userId) &#123;  return selectTransactions(userId, null, null);&#125;private List&lt;Transaction&gt; selectTransactions(Long userId, Date startDate, Date endDate) &#123;  // ...&#125;</code></pre><h2 id="4-函数设计要职责单一"><a href="#4-函数设计要职责单一" class="headerlink" title="4. 函数设计要职责单一"></a>4. 函数设计要职责单一</h2><p>我们在前面讲到单一职责原则的时候，针对的是类、模块这样的应用对象。实际上，对于函数的设计来说，更要满足单一职责原则。相对于类和模块，函数的粒度比较小，代码行数少，所以在应用单一职责原则的时候，没有像应用到类或者模块那样模棱两可，能多单一就多单一。</p><pre><code class="java">public boolean checkUserIfExisting(String telephone, String username, String email)  &#123;   if (!StringUtils.isBlank(telephone)) &#123;    User user = userRepo.selectUserByTelephone(telephone);    return user != null;  &#125;    if (!StringUtils.isBlank(username)) &#123;    User user = userRepo.selectUserByUsername(username);    return user != null;  &#125;    if (!StringUtils.isBlank(email)) &#123;    User user = userRepo.selectUserByEmail(email);    return user != null;  &#125;    return false;&#125;// 拆分成三个函数public boolean checkUserIfExistingByTelephone(String telephone);public boolean checkUserIfExistingByUsername(String username);public boolean checkUserIfExistingByEmail(String email);</code></pre><h2 id="5-移除过深的嵌套层次"><a href="#5-移除过深的嵌套层次" class="headerlink" title="5. 移除过深的嵌套层次"></a>5. 移除过深的嵌套层次</h2><p>代码嵌套层次过深往往是因为 if-else、switch-case、for 循环过度嵌套导致的。我个人建议，嵌套最好不超过两层，超过两层之后就要思考一下是否可以减少嵌套。</p><ul><li>去掉多余的 if 或 else 语句。</li><li>使用编程语言提供的 continue、break、return 关键字，提前退出嵌套</li><li>调整执行顺序来减少嵌套</li><li>将部分嵌套逻辑封装成函数调用，以此来减少嵌套</li></ul><p>除此之外，常用的还有通过使用多态来替代 if-else、switch-case 条件判断的方法。</p><h2 id="6-学会使用解释性变量"><a href="#6-学会使用解释性变量" class="headerlink" title="6. 学会使用解释性变量"></a>6. 学会使用解释性变量</h2><ul><li>常量取代魔法数字。</li></ul><pre><code class="java">public double CalculateCircularArea(double radius) &#123;  return (3.1415) * radius * radius;&#125;// 常量替代魔法数字public static final Double PI = 3.1415;public double CalculateCircularArea(double radius) &#123;  return PI * radius * radius;&#125;</code></pre><ul><li>使用解释性变量来解释复杂表达式。</li></ul><pre><code class="java">if (date.after(SUMMER_START) &amp;&amp; date.before(SUMMER_END)) &#123;  // ...&#125; else &#123;  // ...&#125;// 引入解释性变量后逻辑更加清晰boolean isSummer = date.after(SUMMER_START)&amp;&amp;date.before(SUMMER_END);if (isSummer) &#123;  // ...&#125; else &#123;  // ...&#125; </code></pre><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li>《设计模式之美》</li></ul><p><img src="/../img/geek1.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重构列表-大型重构</title>
      <link href="/2023/02/04/%E5%A4%A7%E5%9E%8B%E9%87%8D%E6%9E%84/"/>
      <url>/2023/02/04/%E5%A4%A7%E5%9E%8B%E9%87%8D%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>对于这些大型重构，有一件事需要注意：它们会耗费相当长的时间。</p><p>在这个过程中，应该根据需要安排自己的工作，只在需要添加新功能或者修复错误的时候才进行重构。</p><p>重构的程度只要能满足其他任务的需要就行了。</p></blockquote><h1 id="1-Tease-Apart-Inheritance-（梳理并分解继承体系）"><a href="#1-Tease-Apart-Inheritance-（梳理并分解继承体系）" class="headerlink" title="1. Tease Apart Inheritance （梳理并分解继承体系）"></a>1. Tease Apart Inheritance （梳理并分解继承体系）</h1><blockquote><p>某个继承体系同时承担两项责任。</p><p>建立两个继承体系，并通过委托关系让其中一个可以调用另外一个。</p></blockquote><ol><li><p><img src="/../img/tai1.png"></p></li><li><p><img src="/../img/tai2.png"></p></li></ol><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>混乱的继承体系是一个严重的问题，因为会导致重复代码，使修改变得困难。</li><li>判断继承体系是否承担了两种不同的责任： 如果继承体系中的某一特定层级上的所有类，其子类名称都以相同的形容词开始，那么这个体系很可能就承担着两项不同的责任。</li></ul><h1 id="2-Convert-Procedural-Design-to-Objects-（将过程化设计转化为对象设计）"><a href="#2-Convert-Procedural-Design-to-Objects-（将过程化设计转化为对象设计）" class="headerlink" title="2. Convert Procedural Design to Objects （将过程化设计转化为对象设计）"></a>2. Convert Procedural Design to Objects （将过程化设计转化为对象设计）</h1><blockquote><p>手上有一些传统过程化风格的代码。</p><p>将数据记录变成对象，将大块的行为分成小块，并将行为移入相关对象之中。</p></blockquote><ol><li><p><img src="/../img/cpdo1.png"></p></li><li><p><img src="/../img/cpdo2.png"></p></li></ol><h2 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h2><ul><li>类中有着长长的过程化函数和极少的数据，旁边则是一堆哑数据对象——除了数据访问函数外没有其他任何函数。</li></ul><h1 id="3-Separate-Domain-from-Presentation（将领域和表述-x2F-显示分离）"><a href="#3-Separate-Domain-from-Presentation（将领域和表述-x2F-显示分离）" class="headerlink" title="3. Separate Domain from Presentation（将领域和表述&#x2F;显示分离）"></a>3. Separate Domain from Presentation（将领域和表述&#x2F;显示分离）</h1><blockquote><p>某些GUI类之中包含了领域逻辑。</p><p>将领域逻辑分离出来，为它们建立独立的领域类(model)。</p></blockquote><ol><li><p><img src="/../img/sdp1.png"></p></li><li><p><img src="/../img/sdp2.png"></p></li></ol><h2 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h2><ul><li>将用户界面代码和领域逻辑分离。领域类不含任何与程序外观相关的代码，只含业务逻辑相关代码。</li></ul><h1 id="4-Extract-Hierarchy（提炼继承体系）"><a href="#4-Extract-Hierarchy（提炼继承体系）" class="headerlink" title="4. Extract Hierarchy（提炼继承体系）"></a>4. Extract Hierarchy（提炼继承体系）</h1><blockquote><p>你有某个类做了太多工作，其中一部分工作是以大量条件表达式完成的。</p><p>建立继续体系，以一个子类表示一种特殊情况。</p></blockquote><ol><li><p><img src="/../img/eh1.png"></p></li><li><p><img src="/../img/eh2.png"></p></li></ol><h2 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h2><ul><li>随着设计方案的演化，最后一个类实现了两个、三个乃至十个不同的概念。</li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li>《重构-改善既有代码的设计》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重构列表-处理概括关系(继承关系)</title>
      <link href="/2023/02/03/%E5%A4%84%E7%90%86%E6%A6%82%E6%8B%AC%E5%85%B3%E7%B3%BB/"/>
      <url>/2023/02/03/%E5%A4%84%E7%90%86%E6%A6%82%E6%8B%AC%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>有一批重构手法专门用来处理类的概括关系（generalization，即继承关系），其中主要是将函数上下移动于继承体系之中。</p></blockquote><h1 id="1-Pull-Up-Field（字段上移）"><a href="#1-Pull-Up-Field（字段上移）" class="headerlink" title="1. Pull Up Field（字段上移）"></a>1. Pull Up Field（字段上移）</h1><blockquote><p>两个子类拥有相同的字段。</p><p>将该字段移至超类。</p></blockquote><pre><code class="java">class Empolyee&#123;&#125;class Salesman extends Employee &#123;  private String name;&#125;class Engineer extends Employee &#123;  private String name;&#125;</code></pre><pre><code class="java">class Empolyee&#123;    protected String name;&#125;class Salesman extends Employee &#123;&#125;class Engineer extends Employee &#123;&#125;</code></pre><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>去除了重复的数据声明</li><li>该字段的行为从子类移动到超类，从而去除重复行为</li></ul><h1 id="2-Pull-Up-Method（函数上移）"><a href="#2-Pull-Up-Method（函数上移）" class="headerlink" title="2. Pull Up Method（函数上移）"></a>2. Pull Up Method（函数上移）</h1><blockquote><p>有些函数，在各个子类中产生完全相同的结果。</p><p>将函数移至超类。</p></blockquote><pre><code class="java">class Empolyee&#123;&#125;class Salesman extends Employee &#123;  private String getName()&#123;&#125;&#125;class Engineer extends Employee &#123;  private String getName()&#123;&#125;&#125;</code></pre><pre><code class="java">class Empolyee&#123;    protected String getName()&#123;&#125;&#125;class Salesman extends Employee &#123;&#125;class Engineer extends Employee &#123;&#125;</code></pre><h2 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h2><ul><li>避免行为重复</li></ul><h1 id="3-Pull-Up-Constructor-Body（构造函数本体上移）"><a href="#3-Pull-Up-Constructor-Body（构造函数本体上移）" class="headerlink" title="3. Pull Up Constructor Body（构造函数本体上移）"></a>3. Pull Up Constructor Body（构造函数本体上移）</h1><blockquote><p>你在各个子类中拥有一些构造函数，它们的本体几乎完全一致。</p><p>在超类中新建一个构造函数，并在子类构造函数中调用它</p></blockquote><pre><code class="java">class Manager extends Employee&#123;  public Manager(String name,String id,int grade) &#123;    _name = name;    _id = id;    _grade = grade;  &#125;&#125;</code></pre><pre><code class="java">class SalesManager extends Manager &#123;   public SalesManager(String name,String id,int grade) &#123;    super(name,id,grade);  &#125;&#125;</code></pre><h2 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h2><ul><li>如果看见各个子类中的函数有共同行为，第一个念头应该是将共同行为提炼到一个独立函数中，然后将这个函数提升到超类。</li></ul><h1 id="4-Push-Down-Method（函数下移）"><a href="#4-Push-Down-Method（函数下移）" class="headerlink" title="4. Push Down Method（函数下移）"></a>4. Push Down Method（函数下移）</h1><blockquote><p>超类中的某个函数只与部分（而非全部）子类有关。</p><p>将这个函数移到相关的那些子类去。</p></blockquote><pre><code class="java">class Employee &#123;  protected void getQuota()&#123;&#125;&#125;class Salesman extends Employee &#123;&#125;class Engineer extends Employee &#123;&#125;</code></pre><pre><code class="java">class Employee &#123;&#125;class Salesman extends Employee &#123;    private void getQuota()&#123;&#125;&#125;class Engineer extends Employee &#123;&#125;</code></pre><h2 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h2><ul><li>当有必要把某些行为从超类移至特定的子类时。</li></ul><h1 id="5-Push-Down-Field（字段下移）"><a href="#5-Push-Down-Field（字段下移）" class="headerlink" title="5. Push Down Field（字段下移）"></a>5. Push Down Field（字段下移）</h1><blockquote><p>超类中的某个字段只被部分（而非全部）子类用到。</p><p>将这个字段移到需要它的那些子类去。</p></blockquote><pre><code class="java">class Employee &#123;  protected String quota;&#125;class Salesman extends Employee &#123;&#125;class Engineer extends Employee &#123;&#125;</code></pre><pre><code class="java">class Employee &#123;&#125;class Salesman extends Employee &#123;    private String quota;&#125;class Engineer extends Employee &#123;&#125;</code></pre><h2 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h2><ul><li>如果只有某些（而非全部）子类需要超类内的一个字段，你可以使用本项重构。</li></ul><h1 id="6-Extract-Subclass（提炼子类）"><a href="#6-Extract-Subclass（提炼子类）" class="headerlink" title="6. Extract Subclass（提炼子类）"></a>6. Extract Subclass（提炼子类）</h1><blockquote><p>类中的某些特性只被某些（而非全部）实例用到。</p><p>新建一个子类，将上面所说的那一部分特性移到子类中。</p></blockquote><pre><code class="java">class JobItem &#123;  double getTotalPrice()&#123;&#125;  double getUnitPrice()&#123;&#125;  Employee getEmployee()&#123;&#125;&#125;</code></pre><pre><code class="java">class JobItem &#123;  double getTotalPrice()&#123;&#125;  double getUnitPrice()&#123;&#125;  Employee getEmployee()&#123;&#125;&#125;class LaborItem extends JobItem &#123;  double getUnitPrice()&#123;&#125;  Employee getEmployee()&#123;&#125;&#125;</code></pre><h2 id="动机-5"><a href="#动机-5" class="headerlink" title="动机"></a>动机</h2><ul><li>发现类中的某些行为只被一部分实例用到，其他实例不需要它们。</li></ul><h1 id="7-Extract-Superclass（提炼超类）"><a href="#7-Extract-Superclass（提炼超类）" class="headerlink" title="7. Extract Superclass（提炼超类）"></a>7. Extract Superclass（提炼超类）</h1><blockquote><p>两个类有相似特性。</p><p>为这两个类建立一个超类，将相同特性移至超类。</p></blockquote><pre><code class="java">class Department &#123;  String getTotalAnnualCost() &#123;&#125;  String getName() &#123;&#125;  int getHeadCount() &#123;&#125;&#125;class Employee &#123;  String getTotalAnnualCost() &#123;&#125;  String getName() &#123;&#125;  int getId() &#123;&#125;&#125;</code></pre><pre><code class="java">class Party &#123;  String getTotalAnnualCost() &#123;&#125;  String getName() &#123;&#125;&#125;class Department extends Party&#123;  int getHeadCount() &#123;&#125;&#125;class Employee extends Party&#123;  int getId() &#123;&#125;&#125;</code></pre><h2 id="动机-6"><a href="#动机-6" class="headerlink" title="动机"></a>动机</h2><ul><li>重复代码是系统中最糟糕的东西之一。</li><li>两个类以相同的方式做类似的事情，或者以不同的方式做类似的事情。</li></ul><h1 id="8-Extract-Interface-（提炼接口）"><a href="#8-Extract-Interface-（提炼接口）" class="headerlink" title="8. Extract Interface （提炼接口）"></a>8. Extract Interface （提炼接口）</h1><blockquote><p>若干客户使用类接口中的同一子集，或者两个类的接口有部分相同。</p><p>将相同的子集提炼到一个独立接口中。</p></blockquote><pre><code class="java">class Employee &#123;  double getRate()&#123;&#125;  boolean hasSpecialSkill()&#123;&#125;  String getName() &#123;&#125;  String getDepartment()&#123;&#125;&#125;</code></pre><pre><code class="java">interface Billable &#123;  double getRate();  boolean hasSpecialSkill();&#125; class Employee implements Billable &#123;  double getRate()&#123;&#125;  boolean hasSpecialSkill()&#123;&#125;  String getName() &#123;&#125;  String getDepartment()&#123;&#125;&#125;</code></pre><h2 id="动机-7"><a href="#动机-7" class="headerlink" title="动机"></a>动机</h2><ul><li>将真正用到的这部分责任分离出来通常很有意义，因为这样可以使系统的用法更清晰，同时也更容易看清系统的责任划分。</li></ul><h1 id="9-Collapse-Hierarchy（折叠继承体系）"><a href="#9-Collapse-Hierarchy（折叠继承体系）" class="headerlink" title="9. Collapse Hierarchy（折叠继承体系）"></a>9. Collapse Hierarchy（折叠继承体系）</h1><blockquote><p>超类和子类之间无太大区别。</p><p>将它们合为一体。</p></blockquote><pre><code class="java">class Employee &#123;&#125;class Salesman extends Employee &#123;&#125;</code></pre><pre><code class="java">class Employee &#123;&#125;</code></pre><h2 id="动机-8"><a href="#动机-8" class="headerlink" title="动机"></a>动机</h2><ul><li>发现某个子类并未带来该有的价值，因此需要把超类与子类合并起来。</li></ul><h1 id="10-Form-Template-Method（塑造模板函数）"><a href="#10-Form-Template-Method（塑造模板函数）" class="headerlink" title="10. Form Template Method（塑造模板函数）"></a>10. Form Template Method（塑造模板函数）</h1><blockquote><p>你有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节上有所不同。</p><p>将这些操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同了。然后将原函数上移至超类。</p></blockquote><pre><code class="java">class Site &#123;&#125;class ResidentialSite extends Site &#123;  String getBillableAmount() &#123;    double base = _units * _rate;    double tax = base * Site.TAX_RATE;    return base + tax;  &#125;&#125;class LifelineSite extends Site &#123;  String getBillableAmount() &#123;    double base = _units * _rate * 0.5;    double tax = base * Site.TAX_RATE * 0.2;    return base + tax;  &#125;  &#125;</code></pre><pre><code class="java">abstract class Site &#123;  double getBillableAmount()&#123;    return getBaseAmount() + getTaxAmount();  &#125;  abstract double getBaseAmount()&#123;&#125;  abstract double getTaxAmount()&#123;&#125;&#125;class ResidentialSite extends Site &#123;  double getBaseAmount()&#123;    return _units * _rate;  &#125;  double getTaxAmount()&#123;    return base * Site.TAX_RATE;  &#125;&#125;class LifelineSite extends Site &#123;   double getBaseAmount()&#123;    return _units * _rate * 0.5;  &#125;  double getTaxAmount()&#123;    return base * Site.TAX_RATE * 0.2;  &#125;&#125;</code></pre><h2 id="动机-9"><a href="#动机-9" class="headerlink" title="动机"></a>动机</h2><ul><li>两个函数以相同顺序执行大致相近的操作，但是各操作不完全相同。</li></ul><h1 id="11-Replace-Inheritance-with-Delegation（以委托取代继承）"><a href="#11-Replace-Inheritance-with-Delegation（以委托取代继承）" class="headerlink" title="11. Replace Inheritance with Delegation（以委托取代继承）"></a>11. Replace Inheritance with Delegation（以委托取代继承）</h1><blockquote><p>某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据。</p><p>在子类中新建一个字段用以保存超类；</p><p>调整子类函数，令它改而委托超类；</p><p>然后去掉两者之间的继承关系。</p></blockquote><pre><code class="java">class Vector &#123;  boolean isEmpty()&#123;&#125;&#125;class Stack extends Vector &#123;  &#125;</code></pre><pre><code class="java">class Stack &#123;  private Vector _vector = new Vector();    public boolean isEmpty()&#123;    return _vector.isEmpty();  &#125;&#125;</code></pre><h2 id="动机-10"><a href="#动机-10" class="headerlink" title="动机"></a>动机</h2><ul><li>以委托取代继承，可以更清楚表明：只需要受托类的一部分功能。</li></ul><h1 id="12-Replace-Delegation-with-Inheritance-（以继承取代委托）"><a href="#12-Replace-Delegation-with-Inheritance-（以继承取代委托）" class="headerlink" title="12. Replace Delegation with Inheritance （以继承取代委托）"></a>12. Replace Delegation with Inheritance （以继承取代委托）</h1><blockquote><p>你在两个类之间使用委托关系，并经常为整个接口编写许多极简单的委托函数。</p><p>让委托类继承受托类。</p></blockquote><pre><code class="java">class Person &#123;  String getName()&#123;&#125;&#125;class Employee &#123;  private Person person = new Person();    String getName() &#123;    return person.getName();  &#125;&#125;</code></pre><pre><code class="java">class Employee extends Person &#123;  String getName()&#123;&#125;&#125;</code></pre><h2 id="动机-11"><a href="#动机-11" class="headerlink" title="动机"></a>动机</h2><ul><li>如果发现需要使用受委托类中的所有函数，并且费了很大力气编写所有极简的委托函数。</li></ul><h2 id="告诫"><a href="#告诫" class="headerlink" title="告诫"></a>告诫</h2><ul><li>并没有使用受托类的<strong>所有函数</strong>，那么就不使用本重构</li><li>受托对象被不止一个其他对象共享，而且受托对象是可变的。</li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li>《重构-改善既有代码的设计》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重构列表-简化函数调用</title>
      <link href="/2023/02/01/%E7%AE%80%E5%8C%96%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"/>
      <url>/2023/02/01/%E7%AE%80%E5%8C%96%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>容易被理解和被使用的**接口(interface)**，是开发良好面向对象软件的关键。</p></blockquote><h1 id="1-Rename-Method（函数改名）"><a href="#1-Rename-Method（函数改名）" class="headerlink" title="1. Rename Method（函数改名）"></a>1. Rename Method（函数改名）</h1><pre><code class="java">class Customer &#123;  String getinvcdtlmt()&#123;&#125;&#125;</code></pre><pre><code class="java">class Customer &#123;  String getInvoiceableCreditLimit()&#123;&#125;&#125;</code></pre><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>将复杂的处理过程分解成小函数是一种好的编程风格，要弄清楚这些小函数的各自的用途，关键在于给函数起一个好名称。</li><li>给函数命名有一个好办法：首先考虑应该给这个函数写上一句怎样的注释，然后想办法将注释变成函数名称。</li></ul><h1 id="2-Add-Parameter（添加参数）"><a href="#2-Add-Parameter（添加参数）" class="headerlink" title="2. Add Parameter（添加参数）"></a>2. Add Parameter（添加参数）</h1><blockquote><p>某个函数需要从调用端得到更多信息</p><p>为此函数添加一个对象参数，让该对象带进函数所需信息。</p></blockquote><pre><code class="java">class Customer &#123;  String getContact()&#123;&#125;&#125;</code></pre><pre><code class="java">class Customer &#123;  String getContact(Date date)&#123;&#125;&#125;</code></pre><h2 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h2><ul><li>必须修改一个函数，而修改后的函数需要一些过去没有的信息，因此需要给该函数添加一个参数</li><li>不使用本重构的时机：除了添加参数外，还有其他选择</li></ul><h1 id="3-Remove-Parameter（移除参数）"><a href="#3-Remove-Parameter（移除参数）" class="headerlink" title="3. Remove Parameter（移除参数）"></a>3. Remove Parameter（移除参数）</h1><blockquote><p>函数本体不再需要某个参数。</p><p>将该参数去除</p></blockquote><pre><code class="java">class Customer &#123;  String getContact(Date date)&#123;&#125;&#125;</code></pre><pre><code class="java">class Customer &#123;  String getContact()&#123;&#125;&#125;</code></pre><h2 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h2><ul><li>不去掉多余参数，函数调用者必须为每一个参数操心。</li></ul><h1 id="4-Separate-Query-from-Modifier（将查询函数和修改函数分离）"><a href="#4-Separate-Query-from-Modifier（将查询函数和修改函数分离）" class="headerlink" title="4. Separate Query from Modifier（将查询函数和修改函数分离）"></a>4. Separate Query from Modifier（将查询函数和修改函数分离）</h1><blockquote><p>某个函数既返回对象状态值，又修改对象状态</p><p>建立两个不同的函数，其中一个负责查询，另一个负责修改</p></blockquote><pre><code class="java">class Customer &#123;  String getTotalOutstandingAndSetReadyForSummaries()&#123;&#125;&#125;</code></pre><pre><code class="java">class Customer &#123;  String getTotalOutstanding()&#123;&#125;  void setReadyForSummaries(String data)&#123;&#125;&#125;</code></pre><h2 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h2><ul><li>任何有返回值的函数，都不应该有看得到的副作用。</li><li>“既有返回值又有副作用”的函数，就应该试着将查询动作从修改动作中分割出来。</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>并发问题</li></ul><h1 id="5-Parameterize-Method（令函数携带参数）"><a href="#5-Parameterize-Method（令函数携带参数）" class="headerlink" title="5. Parameterize Method（令函数携带参数）"></a>5. Parameterize Method（令函数携带参数）</h1><blockquote><p>若干函数做了类似的工作，但在函数本体中却包含了不同的值。</p><p>建立单一函数，以参数表达那些不同的值。</p></blockquote><pre><code class="java">class Employee &#123;  void fivePercentRaise()&#123;&#125;  void tenPercentRaise()&#123;&#125;&#125;</code></pre><pre><code class="java">class Employee &#123;  void raise(double percentage)&#123;&#125;&#125;</code></pre><h2 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h2><ul><li>可能会发现这样的两个函数：做着类似的工作，但因少数几个值导致行为不同。</li><li>重点：以“可将少量数值视为参数”为依据，找出带有重复性的代码。</li></ul><h1 id="6-Replace-Parameter-with-Explicit-Methods（以明确函数取代参数）"><a href="#6-Replace-Parameter-with-Explicit-Methods（以明确函数取代参数）" class="headerlink" title="6. Replace Parameter with Explicit Methods（以明确函数取代参数）"></a>6. Replace Parameter with Explicit Methods（以明确函数取代参数）</h1><blockquote><p>你有一个函数，其中完全取决于参数值而采取不同行为。</p><p>针对该参数的每一个可能值，建立一个独立函数。</p></blockquote><pre><code class="java">void setValue(String name,int value) &#123;  if (name.equals(&quot;height&quot;))&#123;    _height = value;    return;  &#125;  if (name.equals(&quot;width&quot;)) &#123;    _width = value;    return;  &#125;  Assert.shouldNeverReachHere();&#125;</code></pre><pre><code class="java">void setHeight(int arg)&#123;  _height = arg;&#125;void setWidth(int arg) &#123;  _width = arg;&#125;</code></pre><h2 id="动机-5"><a href="#动机-5" class="headerlink" title="动机"></a>动机</h2><ul><li>如果某个参数有多种可能的值，而函数内又以条件表达式检查这些参数，并根据不同参数值做出不同的行为，那么就应该使用本项重构。</li><li>如果参数值不会对函数行为有太多影响，就不应该使用本项重构。</li></ul><h1 id="7-Preserve-Whole-Object-（保持对象完整）"><a href="#7-Preserve-Whole-Object-（保持对象完整）" class="headerlink" title="7. Preserve Whole Object （保持对象完整）"></a>7. Preserve Whole Object （保持对象完整）</h1><blockquote><p>你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。</p><p>改为传递整个对象。</p></blockquote><pre><code class="java">int low = daysTempRange().getLow();int high = daysTempRange().getHigh();withinPlan = plan.withinRange(low,high);</code></pre><pre><code class="java">withinPlan = plan.withinRange(daysTempRange());</code></pre><h2 id="动机-6"><a href="#动机-6" class="headerlink" title="动机"></a>动机</h2><ul><li>万一将来被调用函数需要新的数据项，你就必须查找并修改对此函数的所有调用。</li><li>过长的参数列表难使用，调用者必须记住这些参数的用途。</li></ul><h1 id="8-Replace-Parameter-with-Methods（以函数取代参数）"><a href="#8-Replace-Parameter-with-Methods（以函数取代参数）" class="headerlink" title="8. Replace Parameter with Methods（以函数取代参数）"></a>8. Replace Parameter with Methods（以函数取代参数）</h1><blockquote><p>对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数本身也能够调用前一个函数。</p><p>让参数接受者去除该项参数，并直接调用前一个函数。</p></blockquote><pre><code class="java">int basePrice = _quantity * _itemPrice;discountLevel = getDiscountLevel();double finalPrice = discountedPrice(basePrice,discountLevel);</code></pre><pre><code class="java">int basePrice = _quantity * _itemPrice;double finalPrice = discountedPrice(basePrice);</code></pre><h2 id="动机-7"><a href="#动机-7" class="headerlink" title="动机"></a>动机</h2><ul><li>如果函数可以通过其他途径获得参数值，那么就不应该通过参数取得该值。</li><li>缩减参数列的办法之一就是：看看参数接受端是否可以通过与调用端相同的计算来取得参数值。</li></ul><h1 id="9-Introduce-Parameter-Object-（引入参数对象）"><a href="#9-Introduce-Parameter-Object-（引入参数对象）" class="headerlink" title="9. Introduce Parameter Object （引入参数对象）"></a>9. Introduce Parameter Object （引入参数对象）</h1><blockquote><p>某些参数总是自然地同时出现。</p><p>以一个对象取代这些参数。</p></blockquote><pre><code class="java">class Customer &#123;  int amountInvoicedIn(start: Date,end : Date)&#123;&#125;  int amountReceivedIn(start: Date,end : Date)&#123;&#125;  int amountOverdueIn(start: Date,end : Date)&#123;&#125;&#125;</code></pre><pre><code class="java">class Customer &#123;  int amountInvoicedIn(range: DateRange)&#123;&#125;  int amountReceivedIn(range: DateRange)&#123;&#125;  int amountOverdueIn(range: DateRange)&#123;&#125;&#125;</code></pre><h2 id="动机-8"><a href="#动机-8" class="headerlink" title="动机"></a>动机</h2><ul><li>把这些参数组织到一起后，往往很快可以发现一些可被移至新建类的行为。</li></ul><h1 id="10-Remove-Setting-Method（移除设值函数）"><a href="#10-Remove-Setting-Method（移除设值函数）" class="headerlink" title="10. Remove Setting Method（移除设值函数）"></a>10. Remove Setting Method（移除设值函数）</h1><blockquote><p>类中的某个字段应该在对象创建时被设值，然后就<strong>不再改变</strong>。</p><p>去掉该字段的所有设置函数。</p></blockquote><pre><code class="java">class Employee &#123;  //去掉  //void setImmutableValue(int arg)&#123;&#125;&#125;</code></pre><h2 id="动机-9"><a href="#动机-9" class="headerlink" title="动机"></a>动机</h2><ul><li>如果不希望对象创建后，此字段还有机会被改变，那就不要为它提供设置函数（同时将该字段设为final）</li></ul><h1 id="11-Hide-Method（隐藏函数）"><a href="#11-Hide-Method（隐藏函数）" class="headerlink" title="11. Hide Method（隐藏函数）"></a>11. Hide Method（隐藏函数）</h1><blockquote><p>有一个函数，从来没有被其他任何类用到</p><p>将这个函数修改为<strong>private</strong></p></blockquote><pre><code class="java">class Employee &#123;  public void aMethod()&#123;&#125;&#125;</code></pre><pre><code class="java">class Employee &#123;  private void aMethod()&#123;&#125;&#125;</code></pre><h2 id="动机-10"><a href="#动机-10" class="headerlink" title="动机"></a>动机</h2><ul><li>当面对一个过于丰富、提供了过多行为的接口时，就值得将非必要的取值函数和设值函数隐藏起来。</li></ul><h1 id="12-Replace-Constructor-with-Factory-Method（以工厂函数取代构造函数）"><a href="#12-Replace-Constructor-with-Factory-Method（以工厂函数取代构造函数）" class="headerlink" title="12. Replace Constructor with Factory Method（以工厂函数取代构造函数）"></a>12. Replace Constructor with Factory Method（以工厂函数取代构造函数）</h1><blockquote><p>你希望在创建对象时不仅仅是做简单的建构动作。</p><p><strong>将构造函数替换为工厂函数。</strong></p></blockquote><pre><code class="java">Employee(int type) &#123;  _type = type;&#125;</code></pre><pre><code class="java">static Employee create(int type) &#123;  return new Employee(type);&#125;</code></pre><h2 id="动机-11"><a href="#动机-11" class="headerlink" title="动机"></a>动机</h2><ul><li>最显而易见的动机：在派生子类的过程中以工厂函数取代类型码。</li><li>创建名单中如果还得加上子类，那些子类也是根据类型码来创建。</li></ul><h1 id="13-Encapsulate-Downcast-（封装向下转型）"><a href="#13-Encapsulate-Downcast-（封装向下转型）" class="headerlink" title="13. Encapsulate Downcast （封装向下转型）"></a>13. Encapsulate Downcast （封装向下转型）</h1><blockquote><p>某个函数返回的对象，需要由函数调用者执行向下转型（downcast)。</p><p><strong>将向下转型动作移到函数中。</strong></p></blockquote><pre><code class="java">Object lastReading() &#123;  return readings.lastElement();&#125;</code></pre><pre><code class="java">Reading lastReading() &#123;  return (Reading)readings.lastElement();&#125;</code></pre><h2 id="动机-12"><a href="#动机-12" class="headerlink" title="动机"></a>动机</h2><ul><li>由于计算对象类型往往比较麻烦，你还是常常需要告诉编译器对象的确切类型。</li></ul><h1 id="14-Replace-Error-Code-with-Exception-（以异常取代错误码）"><a href="#14-Replace-Error-Code-with-Exception-（以异常取代错误码）" class="headerlink" title="14. Replace Error Code with Exception （以异常取代错误码）"></a>14. Replace Error Code with Exception （以异常取代错误码）</h1><blockquote><p>某个函数返回一个特定的代码，用以表示某种错误的情况。</p><p>改用异常。</p></blockquote><pre><code class="java">int withdraw(int amount) &#123;  if (amount &gt; _balance)    return -1;  else &#123;    _balance -= amount;    return 0;  &#125;&#125;</code></pre><pre><code class="java">void withdraw(int amount) thows BalanceException &#123;  if (amount &gt; _balance) throw new BalanceException();  _balance -= amount;&#125;</code></pre><h2 id="动机-13"><a href="#动机-13" class="headerlink" title="动机"></a>动机</h2><ul><li>如果程序比较重要，就需要以更认真的方式来处理。</li><li>更好的错误处理方式：异常。 将“普通程序” 和 “错误处理”分开了，这使得程序更容易理解。</li></ul><h1 id="15-Replace-Exception-with-Test（以测试取代异常）"><a href="#15-Replace-Exception-with-Test（以测试取代异常）" class="headerlink" title="15. Replace Exception with Test（以测试取代异常）"></a>15. Replace Exception with Test（以测试取代异常）</h1><blockquote><p>面对一个调用者可以预先检查的条件，你抛出了一个异常。</p><p>修改调用者，使它在调用函数之前先做检查。</p></blockquote><pre><code class="java">double getValueForPeriod(int periodNumber)&#123;  try &#123;    return _values[periodNumber];  &#125;catch(ArrayIndexOutOfBoundsException e)&#123;    return 0;  &#125;&#125;</code></pre><pre><code class="java">double getValueForPeriod(int periodNumber)&#123;      if (periodNumber &gt;= _values.length) return 0;    return _values[periodNumber];&#125;</code></pre><h2 id="动机-14"><a href="#动机-14" class="headerlink" title="动机"></a>动机</h2><ul><li>“异常”只应该被用于异常的、罕见的行为，也就少那些产生意料之外的错误的行为，而不应该成为条件检查的替代品。</li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li>《重构-改善既有代码的设计》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重构列表-简化条件表达式</title>
      <link href="/2023/01/31/%E7%AE%80%E5%8C%96%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2023/01/31/%E7%AE%80%E5%8C%96%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Decompose-Conditional（分解条件表达式）"><a href="#1-Decompose-Conditional（分解条件表达式）" class="headerlink" title="1. Decompose Conditional（分解条件表达式）"></a>1. Decompose Conditional（分解条件表达式）</h1><blockquote><p>你有一个复杂的条件（if-then-else）语句</p><p>从if、then、else三个段落中分别提炼出独立函数</p></blockquote><pre><code class="java">if (data.before(SUMMER_START) || data.after(SUMMER_END)) &#123;      charge = quantity * _winterRate + _winterServiceChange;&#125; else &#123;      charge = quantity * _summerRate;&#125;</code></pre><pre><code class="java">if (notSummer(data))  charge = winterCharge(quantity);else charge = summerCharge(quantity);</code></pre><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>大型函数自身就会使代码的可读性下降，而条件逻辑则会使代码更难阅读</li><li>将每个分支条件分解成新函数的好处：可以突出条件逻辑，更清楚地表明每个分支的作用，并且突出每个分支的原因。</li></ul><h1 id="2-Consolidate-Conditional-Expression（合并条件表达式）"><a href="#2-Consolidate-Conditional-Expression（合并条件表达式）" class="headerlink" title="2. Consolidate Conditional Expression（合并条件表达式）"></a>2. Consolidate Conditional Expression（合并条件表达式）</h1><blockquote><p>有一系列条件测试，都得到<strong>相同的结果</strong></p><p>将这些测试合并为一个条件表达式，并将这个条件表达式提炼成为一个独立函数。</p></blockquote><pre><code class="java">double disabilityAmount() &#123;  if (_seniority &lt; 2) return 0;  if (_monthsDisabled &gt; 12) return 0;  if (_isPartTime) return 0;&#125;</code></pre><pre><code class="java">double disabilityAmount() &#123;  if (isNotEligibleForDisability()) return 0;&#125;</code></pre><h2 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h2><ul><li>合并后的条件代码会让检查的用意更清晰。</li><li>这项重构往往可以为你使用Extract Method做好准备。</li></ul><h1 id="3-Consolidate-Duplicate-Conditional-Fragments（合并重复的条件片段）"><a href="#3-Consolidate-Duplicate-Conditional-Fragments（合并重复的条件片段）" class="headerlink" title="3. Consolidate Duplicate Conditional Fragments（合并重复的条件片段）"></a>3. Consolidate Duplicate Conditional Fragments（合并重复的条件片段）</h1><blockquote><p>在条件表达式的每个分支上有着相同的一段代码</p><p>将这段重复代码搬移到条件表达式之外</p></blockquote><pre><code class="java">if (isSpecialDeal()) &#123;  total = price * 0.95;  send();&#125; else &#123;  total = price * 0.98;  send();&#125;</code></pre><pre><code class="java">if (isSpecialDeal()) &#123;  total = price * 0.95;&#125; else &#123;  total = price * 0.98;&#125;send();</code></pre><h2 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h2><ul><li>所有分支都执行了相同的某段代码，将这段代码搬到条件表达式的外面。这样，代码才能更清楚地表明哪些东西随条件的变化而变化、哪些东西保持不变。</li></ul><h1 id="4-Remove-Control-Flag-（移除控制标记）"><a href="#4-Remove-Control-Flag-（移除控制标记）" class="headerlink" title="4. Remove Control Flag （移除控制标记）"></a>4. Remove Control Flag （移除控制标记）</h1><blockquote><p>在一系列布尔表达式中，某个变量带有“控制标记”（control flag）的作用。</p><p><strong>以break语句或return语句取代控制标记。</strong></p></blockquote><h2 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h2><pre><code>set done to falsewhile not done    if (condition)        do something        set done to true    next step of loop</code></pre><p>这样的控制标记带来的麻烦超过了它所带来的便利。</p><p>结构化编程原则告诉他们： 每个子程序只能有一个入口和一个出口。</p><p>“单一出口”原则会让你在代码中加入讨厌的控制标记，大大降低条件表达式的可读性。</p><h1 id="5-Replace-Nested-Conditional-with-Guard-Clauses（卫语句取代嵌套条件表达式）"><a href="#5-Replace-Nested-Conditional-with-Guard-Clauses（卫语句取代嵌套条件表达式）" class="headerlink" title="5. Replace Nested Conditional with Guard Clauses（卫语句取代嵌套条件表达式）"></a>5. Replace Nested Conditional with Guard Clauses（卫语句取代嵌套条件表达式）</h1><blockquote><p>函数中的条件逻辑使人难以看清楚正常的执行路径。</p><p>使用卫语句表现所有特殊情况。</p><ul><li>如果条件极其罕见，就应该单独检查条件，并在该条件为真的时候，从函数中返回。这样单独检查常常被称为“卫语句”(guard clauses)</li></ul></blockquote><pre><code class="java">double getPayAmount() &#123;  double result;  if (_isDead) result = deadAmount();  else    if (_isSeparated) result = separatedAmount();      else &#123;      if (isRetired) result = retiredAmount();      else result = normalPayAmount();    &#125;  return result;&#125;</code></pre><pre><code class="java">double getPayAmount() &#123;  if (isDead) return deadAmount();  if (_isSeparated) return separatedAmount();  if (_isRetired) return retiredAmount();  return normalPayAmount();&#125;</code></pre><h2 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h2><ul><li>精髓：给某一个条件分支以特别的重视</li></ul><h1 id="6-Replace-Conditional-with-Polymorphism（以多态取代条件表达式）"><a href="#6-Replace-Conditional-with-Polymorphism（以多态取代条件表达式）" class="headerlink" title="6. Replace Conditional with Polymorphism（以多态取代条件表达式）"></a>6. Replace Conditional with Polymorphism（以多态取代条件表达式）</h1><blockquote><p>你手上有个条件表达式，它根据对象类型的不同而选择不同的行为。</p><p>将这个条件表达式的每一个分支放进一个子类内的重写函数中，然后将原始函数声明为抽象函数。</p></blockquote><pre><code class="java">double getSpeed() &#123;  switch(_type) &#123;    case EUROPEAN :      return getBaseSpeed();    case AFRICAN:      return getBaseSpeed()-getLoadFactor() * _numberOfCoconuts;    case NORWEGIAN_BLUE:      return (_isNailed)? 0 : getBaseSpeed(_voltage);  &#125;  throw new RuntimeException(&quot;Should be unreachable&quot;);&#125;</code></pre><pre><code class="java">class Bird &#123;  double getSpeed()&#123;      switch(_type) &#123;        case EUROPEAN :          return European().getSpeed();        case AFRICAN:          return African().getSpeed();        case NORWEGIAN_BLUE:          return NorwegianBlue().getSpeed();      &#125;      throw new RuntimeException(&quot;Should be unreachable&quot;);  &#125;&#125;class European extends Bird&#123;  double getSpeed()&#123;    return getBaseSpeed();  &#125;&#125;class African extends Bird&#123;  double getSpeed()&#123;    return getBaseSpeed()-getLoadFactor() * _numberOfCoconuts;  &#125;&#125;class NorwegianBlue extends Bird&#123;  double getSpeed()&#123;    return (_isNailed)? 0 : getBaseSpeed(_voltage);  &#125;&#125;</code></pre><h2 id="动机-5"><a href="#动机-5" class="headerlink" title="动机"></a>动机</h2><ul><li>多态最根本的好处就是：如果你需要根据对象的不同类型而采取不同的行为，多态使你不必编写明显的条件表达式。</li><li>如果同一组条件表达式在程序许多地点出现，那么使用多态的收益是最大的。</li></ul><h1 id="7-Introduce-Null-Object（引入Null对象）"><a href="#7-Introduce-Null-Object（引入Null对象）" class="headerlink" title="7. Introduce Null Object（引入Null对象）"></a>7. Introduce Null Object（引入Null对象）</h1><blockquote><p>你需要再三检查某对象是否为null</p><p>将null值替换为null对象</p></blockquote><pre><code class="java">if (customer == null) plan = BillingPlan.basic();else plan = customer.getPlan();</code></pre><pre><code class="java">interface Nullable &#123;  boolean isNull();&#125;class NullCustomer extends Customer implements Nullable&#123;  public boolean isNull() return true;&#125;class Customer implements Nullable&#123;  public boolean isNull() return false;    static Customer newNull() &#123;    return new NullCustomer();  &#125;&#125;class Site &#123;  // 不返回Null,而是返回一个NullCustomer对象  Customer getCustomer() &#123;    return (_customer == null)? Customer.newNull() : _customer;  &#125;    if (customer.isNull()) plan = BillingPlan.basic();    else plan = customer.getPlan();&#125;</code></pre><h2 id="动机-6"><a href="#动机-6" class="headerlink" title="动机"></a>动机</h2><ul><li>当某个字段内容为null时，多态可扮演另一个较不直观的用途</li></ul><h1 id="8-Introduce-Assertion（引入断言）"><a href="#8-Introduce-Assertion（引入断言）" class="headerlink" title="8. Introduce Assertion（引入断言）"></a>8. Introduce Assertion（引入断言）</h1><blockquote><p>某一段代码需要对程序状态做出某种假设</p><p>以断言明确表现这种假设。</p></blockquote><pre><code class="java">double getExpenseLimit() &#123;  return (_expenseLimit != NULL_EXPENSE)?    _expenseLimit :      _primaryProject.getMemberExpenseLimit();&#125;</code></pre><pre><code class="java">double getExpenseLimit() &#123;  Assert.isTrue(_expenseLimit != NULL_EXPENSE || _primaryProject != null);  return (_expenseLimit != NULL_EXPENSE)?    _expenseLimit :      _primaryProject.getMemberExpenseLimit();&#125;</code></pre><h2 id="动机-7"><a href="#动机-7" class="headerlink" title="动机"></a>动机</h2><ul><li>常常会有一段代码：只有当某个条件为真时，该段代码才能正常运行。使用断言明确标明这些假设。</li><li>断言可作为交流与调试的辅助</li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li>《重构-改善既有代码的设计》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重构列表-重新组织数据</title>
      <link href="/2023/01/25/%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E6%95%B0%E6%8D%AE/"/>
      <url>/2023/01/25/%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Self-Encapsulate-Field（自封装字段）"><a href="#1-Self-Encapsulate-Field（自封装字段）" class="headerlink" title="1. Self Encapsulate Field（自封装字段）"></a>1. Self Encapsulate Field（自封装字段）</h1><blockquote><p>为这个字段建立取值&#x2F;设值函数，并且只以这些函数来访问字段</p></blockquote><pre><code class="java">private int _low ,_high;bolean includes (int arg) &#123;  return arg &gt;= _low &amp;&amp; arg &lt;= _high;&#125;</code></pre><pre><code class="java">private int _low ,_high;bolean includes (int arg) &#123;  return arg &gt;= getLow() &amp;&amp; arg &lt;= getHigh();&#125;int getLow() &#123;return _low;&#125;int getHigh()&#123;return _high;&#125;</code></pre><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>如果想访问超类的一个字段，却又想在子类中将对这个变量的访问改为一个计算后的值。</li></ul><h1 id="2-Replace-Data-Value-with-Object-（以对象取代数据值）"><a href="#2-Replace-Data-Value-with-Object-（以对象取代数据值）" class="headerlink" title="2. Replace Data Value with Object （以对象取代数据值）"></a>2. Replace Data Value with Object （以对象取代数据值）</h1><blockquote><p>将数据项变成对象</p></blockquote><ol><li><p><img src="/../img/replaceDataValueWithObj1.png"></p></li><li><p><img src="/../img/replaceDataValueWithObj2.png"></p></li></ol><h2 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h2><ul><li>当Duplicate Code 坏味道和Feature Envy坏味道开始出现，就应该将数据值变成对象</li></ul><h1 id="3-Change-Value-to-Reference-（将值对象改为引用对象）"><a href="#3-Change-Value-to-Reference-（将值对象改为引用对象）" class="headerlink" title="3. Change Value to Reference （将值对象改为引用对象）"></a>3. Change Value to Reference （将值对象改为引用对象）</h1><blockquote><p>将这个值对象变成引用对象</p></blockquote><ol><li><p><img src="/../img/replaceDataValueWithObj2.png"></p></li><li><p><img src="/../img/changeValuetoReference.png"></p></li></ol><h2 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h2><ul><li>对对象做一个有用的分类：引用对象和值对象。</li><li>可能会希望给这个对象加入一些可修改数据，并确保对任何一个对象的修改都能影响到所有引用此一对象的地方。这个时候就要将对象变成一个引用对象。</li></ul><h1 id="4-Change-Reference-to-Value-（将引用对象改为值对象）"><a href="#4-Change-Reference-to-Value-（将引用对象改为值对象）" class="headerlink" title="4. Change Reference to Value （将引用对象改为值对象）"></a>4. Change Reference to Value （将引用对象改为值对象）</h1><blockquote><p>将它变成一个值对象</p></blockquote><ol><li><p><img src="/../img/changeValuetoReference.png"></p></li><li><p><img src="/../img/replaceDataValueWithObj2.png"></p></li></ol><h2 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h2><ul><li>引用对象开始变得难以使用，也许就应该将它改为值对象</li><li>值对象有一个非常重要的特质：不可变</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>如果无法将该对象修改为不可变的，则放弃使用本项重构</li><li>建立equals() 和 hashCode()</li></ul><h1 id="5-Replace-Array-with-Object-（以对象取代数组）"><a href="#5-Replace-Array-with-Object-（以对象取代数组）" class="headerlink" title="5. Replace Array with Object （以对象取代数组）"></a>5. Replace Array with Object （以对象取代数组）</h1><blockquote><p>以对象替换数组。对数组中的每个元素，以一个字段来表示</p></blockquote><pre><code class="java">String[] row = new String[3];row[0] = &quot;LiverPool&quot;;row[1] = &quot;15&quot;;</code></pre><pre><code class="java">Performance row = new Performance();row.setName(&quot;LiverPool&quot;);row.setWins(&quot;15&quot;);</code></pre><h2 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h2><ul><li>一个数组容纳来多种不同的对象，会给用户带来麻烦</li></ul><h1 id="6-Duplicate-Observed-Data-（复制“被监视数据”）"><a href="#6-Duplicate-Observed-Data-（复制“被监视数据”）" class="headerlink" title="6. Duplicate Observed Data （复制“被监视数据”）"></a>6. Duplicate Observed Data （复制“被监视数据”）</h1><blockquote><p>将该数据复制到一个领域对象中。建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据。</p></blockquote><ol><li><p><img src="/../img/duplicateObservedData1.png"></p></li><li></li></ol><p><img src="/../img/duplicateObservedData2.webp"></p><h2 id="动机-5"><a href="#动机-5" class="headerlink" title="动机"></a>动机</h2><ul><li>将处理用户界面和处理业务逻辑的代码分开</li></ul><h1 id="7-Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向关联）"><a href="#7-Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向关联）" class="headerlink" title="7. Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）"></a>7. Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）</h1><blockquote><p>添加一个反向指针，并使修改函数能够同时更新两条连接</p></blockquote><p>1. </p><p><img src="/../img/cuab1.webp"></p><ol start="2"><li><img src="/../img/cuab2.webp"></li></ol><h2 id="动机-6"><a href="#动机-6" class="headerlink" title="动机"></a>动机</h2><ul><li>引用类需要得到其引用者以便进行某些处理</li></ul><h1 id="8-Change-Bidirectional-Association-to-Unidirectional（将双向关联改为单向关联）"><a href="#8-Change-Bidirectional-Association-to-Unidirectional（将双向关联改为单向关联）" class="headerlink" title="8. Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）"></a>8. Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）</h1><blockquote><p>去除不必要的关联</p></blockquote><ol><li><img src="/../img/cuab2.webp"></li><li><img src="/../img/cuab1.webp"></li></ol><h2 id="动机-7"><a href="#动机-7" class="headerlink" title="动机"></a>动机</h2><ul><li>维护双向连接、确保对象被正确创建和删除，增加了复杂度</li><li>大量的双向连接很容易造成“僵尸对象”</li><li>双向关联迫使两个类之间有了依赖</li></ul><h1 id="9-Replace-Magic-Number-with-Symbolic-Constant-（以字面量取代魔法数）"><a href="#9-Replace-Magic-Number-with-Symbolic-Constant-（以字面量取代魔法数）" class="headerlink" title="9. Replace Magic Number with Symbolic Constant （以字面量取代魔法数）"></a>9. Replace Magic Number with Symbolic Constant （以字面量取代魔法数）</h1><blockquote><p>创造一个常量，根据其意义为它命名，并将上述的字面量值替换为这个常量</p></blockquote><pre><code class="java">double potentialEnergy(double mass , double height) &#123;  return mass * 9.81 * height;&#125;</code></pre><pre><code class="java">static final double GRAVITATIONAL_CONSTANT = 9.18;double potentialEnergy(double mass , double height) &#123;  return mass * GRAVITATIONAL_CONSTANT * height;&#125;</code></pre><h2 id="动机-8"><a href="#动机-8" class="headerlink" title="动机"></a>动机</h2><ul><li>魔法数是指拥有特殊意义，却又不能明确表现出这种意义的数字。一旦这些数发生改变，查找修改是一场噩梦。</li><li>常量不会造成任何性能开销，却可以大大提高代码的可读性。</li></ul><h1 id="10-Encapsulate-Field-（封装字段）"><a href="#10-Encapsulate-Field-（封装字段）" class="headerlink" title="10. Encapsulate Field （封装字段）"></a>10. Encapsulate Field （封装字段）</h1><blockquote><p>将它声明为private ，并提供相应的访问函数</p></blockquote><pre><code class="java">public String _name;</code></pre><pre><code class="java">private String _name;public String getName() &#123;  return _name;&#125;public void setName(String arg)&#123;  _name = arg;&#125;</code></pre><h2 id="动机-9"><a href="#动机-9" class="headerlink" title="动机"></a>动机</h2><ul><li>面向对象的首要原则之一就是封装，或者成为“数据隐藏”。</li><li>数据声明为public是一种不好的做法，因为这样会降低程序的模块化程度。</li></ul><h1 id="11-Encapsulate-Collection-（封装集合）"><a href="#11-Encapsulate-Collection-（封装集合）" class="headerlink" title="11. Encapsulate Collection （封装集合）"></a>11. Encapsulate Collection （封装集合）</h1><blockquote><p>让这个函数返回该集合的一个只读副本，并在这个类中提供添加&#x2F;移除集合元素的函数。</p></blockquote><ol><li><p><img src="/../img/ec1.png"></p></li><li><p><img src="/../img/ec2.png"></p></li></ol><h2 id="动机-10"><a href="#动机-10" class="headerlink" title="动机"></a>动机</h2><ul><li>取值函数不该返回集合本身，应该避免用户直接操作对象内所保存的集合，并隐藏对象内与用户无关的数据结构。</li><li>不应该为这整个集合提供一个设值函数，但应该提供集合添加&#x2F;移除元素的函数。</li></ul><h1 id="12-Replace-Record-with-Data-Class（以数据类取代记录）"><a href="#12-Replace-Record-with-Data-Class（以数据类取代记录）" class="headerlink" title="12. Replace Record with Data Class（以数据类取代记录）"></a>12. Replace Record with Data Class（以数据类取代记录）</h1><blockquote><p>为该记录创建一个“哑”数据对象。</p></blockquote><h2 id="动机-11"><a href="#动机-11" class="headerlink" title="动机"></a>动机</h2><ul><li>程序是通过一个传统API来与记录结构交流，或者处理从数据库读出的记录。这时候就需要创建一个接口类，用以处理这些外来数据。</li></ul><h1 id="13-Replace-Type-Code-with-Class-（以类取代类型码）"><a href="#13-Replace-Type-Code-with-Class-（以类取代类型码）" class="headerlink" title="13. Replace Type Code with Class （以类取代类型码）"></a>13. Replace Type Code with Class （以类取代类型码）</h1><blockquote><p>以一个新的类替换该数值类型码</p></blockquote><ol><li><p><img src="/../img/rtcc1.png"></p></li><li><p><img src="/../img/rtcc2.webp"></p></li></ol><h2 id="动机-12"><a href="#动机-12" class="headerlink" title="动机"></a>动机</h2><ul><li>任何接受类型码作为参数的函数，所期望的实际上是一个数值，无法强制使用符号名</li><li>如果将数值换成一个类，编译器就可以对这个类进行类型检验</li></ul><h1 id="14-Replace-Type-Code-with-Subclasses-（以子类取代类型码）"><a href="#14-Replace-Type-Code-with-Subclasses-（以子类取代类型码）" class="headerlink" title="14. Replace Type Code with Subclasses （以子类取代类型码）"></a>14. Replace Type Code with Subclasses （以子类取代类型码）</h1><blockquote><p>以子类取代这个类型码</p></blockquote><ol><li><p><img src="/../img/rtcs1.png"></p></li><li><p><img src="/../img/rtcs2.webp"></p></li></ol><pre><code class="java">static Employee create(int type) &#123;  switch(type) &#123;    case ENGINEER :      return new Engineer();    case SALESMAN:      return new Salesman();    default :        throw new IllegalArgumentException(&quot;Incorrect type code value&quot;);    &#125;&#125;</code></pre><h2 id="动机-13"><a href="#动机-13" class="headerlink" title="动机"></a>动机</h2><ul><li>如果类型码影响宿主类的行为，那么最好的办法就是借助多态来处理变化行为</li><li>一般这种情况的标志就是像switch这样的条件表达式</li></ul><h1 id="15-Replace-Type-Code-with-State-x2F-Strategy-（以State-x2F-Strategy取代类型码）"><a href="#15-Replace-Type-Code-with-State-x2F-Strategy-（以State-x2F-Strategy取代类型码）" class="headerlink" title="15. Replace Type Code with State&#x2F;Strategy （以State&#x2F;Strategy取代类型码）"></a>15. Replace Type Code with State&#x2F;Strategy （以State&#x2F;Strategy取代类型码）</h1><blockquote><p>以状态对象取代类型码</p></blockquote><ol><li><p><img src="/../img/rtcs1.png"></p></li><li><p><img src="/../img/rtcss.webp"></p></li></ol><h2 id="动机-14"><a href="#动机-14" class="headerlink" title="动机"></a>动机</h2><ul><li>如果“类型码的值在对象生命周期中发生变化” 或 “其他原因使得宿主类不能被继承”，可以使用本重构</li><li>本重构使用State模式（状态模式）或Strategy模式（策略模式）</li></ul><h1 id="16-Replace-Subclass-with-Fields-（以字段取代子类）"><a href="#16-Replace-Subclass-with-Fields-（以字段取代子类）" class="headerlink" title="16. Replace Subclass with Fields （以字段取代子类）"></a>16. Replace Subclass with Fields （以字段取代子类）</h1><blockquote><p>修改这些函数，使它们返回超类中的某个（新增）字段，然后销毁子类</p></blockquote><ol><li><p><img src="/../img/rsf1.webp"></p></li><li></li></ol><p><img src="/../img/rsf2.png"></p><h2 id="动机-15"><a href="#动机-15" class="headerlink" title="动机"></a>动机</h2><ul><li>建立子类的目的是为了增加新特性或变化其行为。有一种变化行为成为“常量函数”，会返回一个硬编码的值。</li><li>若子类中只有常量函数，实在没有足够的存在价值。可以去除这样的子类，避免因继承而带来的额外复杂性。</li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li>《重构-改善既有代码的设计》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重构列表-在对象之间搬移特性</title>
      <link href="/2023/01/23/%E5%9C%A8%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E6%90%AC%E7%A7%BB%E7%89%B9%E6%80%A7/"/>
      <url>/2023/01/23/%E5%9C%A8%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E6%90%AC%E7%A7%BB%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在对象的设计过程中，“决定把责任放在哪儿” 即使不是最重要的事，也是最重要的事之一。</p></blockquote><h1 id="1-Move-Method（搬移函数）"><a href="#1-Move-Method（搬移函数）" class="headerlink" title="1. Move Method（搬移函数）"></a>1. Move Method（搬移函数）</h1><blockquote><p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是将旧函数完全移除。</p></blockquote><p><img src="/../img/moveMethod1.png"></p><p><img src="/../img/moveMethod2.png"></p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>如果一个类有太多行为，或如果一个类与另一个类有太多合作而形成高度耦合，就搬移函数。</li><li>使用另一个对象的次数比使用自己所驻对象的次数还多。</li></ul><h1 id="2-Move-Field（搬移字段）"><a href="#2-Move-Field（搬移字段）" class="headerlink" title="2. Move Field（搬移字段）"></a>2. Move Field（搬移字段）</h1><blockquote><p>在目标类新建一个字段，修改源字段的所有用户，令它们改用新字段。</p></blockquote><p><img src="/../img/moveField1.png"></p><p><img src="/../img/moveField2.png"></p><h2 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h2><ul><li>对于一个字段，在其所驻类之外的另一个类中有更多函数使用了它，就会考虑搬移这个字段。</li></ul><h1 id="3-Extract-Class（提炼类）"><a href="#3-Extract-Class（提炼类）" class="headerlink" title="3. Extract Class（提炼类）"></a>3. Extract Class（提炼类）</h1><blockquote><p>建立一个新类，将相关的字段和函数从旧类搬移到新类。</p></blockquote><p><img src="/../img/extractClass1.png"></p><p><img src="/../img/extractClass2.png"></p><h2 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h2><ul><li>一个类应该是一个清楚的抽象，处理一些明确的责任</li><li>类含有大量函数和数据</li><li>开发后期出现的信号是类的子类化方式</li></ul><h1 id="4-Inline-Class-（将类内联化）"><a href="#4-Inline-Class-（将类内联化）" class="headerlink" title="4. Inline Class （将类内联化）"></a>4. Inline Class （将类内联化）</h1><blockquote><p>将这个类的所有特性搬移到另一个类中，然后移除原类</p></blockquote><ol><li></li></ol><p><img src="/../img/extractClass2.png"></p><ol start="2"><li></li></ol><p><img src="/../img/extractClass1.png"></p><h2 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h2><ul><li>如果一个类不再承担足够责任、不再有单独存在的理由</li></ul><h1 id="5-Hide-Delegate-（隐藏“委托关系”）"><a href="#5-Hide-Delegate-（隐藏“委托关系”）" class="headerlink" title="5. Hide Delegate （隐藏“委托关系”）"></a>5. Hide Delegate （隐藏“委托关系”）</h1><blockquote><p>在服务类上建立客户所需的所有函数，用以隐藏委托关系</p></blockquote><ol><li></li></ol><p><img src="/../img/hideDelegate1.png"></p><ol start="2"><li><img src="/../img/hideDelegate2.png"></li></ol><h2 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h2><ul><li>“封装”意味着每个对象都应该尽可能少了解系统的其他部分。</li><li>万一委托关系发生变化，客户也得相应变化。将委托关系隐藏起来，从而去除这种依赖。</li></ul><h1 id="6-Remove-Middle-Man-（移除中间人）"><a href="#6-Remove-Middle-Man-（移除中间人）" class="headerlink" title="6. Remove Middle Man （移除中间人）"></a>6. Remove Middle Man （移除中间人）</h1><blockquote><p>让客户直接调用受委托类</p></blockquote><ol><li><p><img src="/../img/hideDelegate2.png"></p></li><li><p><img src="/../img/hideDelegate1.png"></p></li></ol><h2 id="动机-5"><a href="#动机-5" class="headerlink" title="动机"></a>动机</h2><ul><li>“封装受委托对象”要付出代价： 每当客户要使用委托类的新特性时，你就必须在服务端添加一个简单的委托函数。随着受委托的特性越来越多，服务类完全变成了一个“中间人”。</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>也可能想保留一部分委托关系。希望对某些客户隐藏委托关系，对另一些用户直接使用委托关系。</li></ul><h1 id="7-Introduce-Foreign-Method（引入外加函数）"><a href="#7-Introduce-Foreign-Method（引入外加函数）" class="headerlink" title="7. Introduce Foreign Method（引入外加函数）"></a>7. Introduce Foreign Method（引入外加函数）</h1><blockquote><p>在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。</p></blockquote><pre><code class="java">Date newStart = new Date(previousEnd.getYear(),previousEnd.getMonth(),previousEnd.getDate()+1);</code></pre><pre><code class="java">Date newStart = nextDate(previousEnd);private static Date nextDate(Date arg) &#123;  // foreign method, should be on date  return new Date(arg.getYear(),arg.getMonth(),arg.getDate()+1);&#125;</code></pre><h2 id="动机-6"><a href="#动机-6" class="headerlink" title="动机"></a>动机</h2><ul><li>需要一项新的服务，这个类无法供应</li><li>明确信号：这个函数原本应该在提供服务的类中实现</li></ul><h1 id="8-Introduce-Local-Extension-（引入本地扩展）"><a href="#8-Introduce-Local-Extension-（引入本地扩展）" class="headerlink" title="8. Introduce Local Extension （引入本地扩展）"></a>8. Introduce Local Extension （引入本地扩展）</h1><blockquote><p>建立一个新类，使它包含这些额外函数。让其成为源类的子类或者包装类</p></blockquote><ol><li><img src="/../img/introduceLocalExtension1.png"></li><li><img src="/../img/introduceLocalExtension2.png"></li></ol><h2 id="动机-7"><a href="#动机-7" class="headerlink" title="动机"></a>动机</h2><ul><li>需要的额外函数超过两个，外加函数很难控制。需要将这些函数组织在一起，放到恰当的地方</li><li>要达到这一目的，两种标准对象技术—— 子类化（subclassing）和包装（wrapping）——统称本地扩展（local extension)</li></ul><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><ul><li>一般来说，不在扩展类中重写原始类的函数，只会添加新函数</li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li>《重构-改善既有代码的设计》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重构列表-重新组织函数</title>
      <link href="/2023/01/20/%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E5%87%BD%E6%95%B0/"/>
      <url>/2023/01/20/%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>几乎所有时刻，问题都源于Long Method(过长函数)</p></blockquote><h1 id="1-Extract-Method-提炼函数"><a href="#1-Extract-Method-提炼函数" class="headerlink" title="1. Extract Method(提炼函数)"></a>1. Extract Method(提炼函数)</h1><pre><code class="java">void printOwing(double amount) &#123;        printBanner();                //print details        System.out.println(&quot;....&quot;);        System.out.println(&quot;....&quot; + amount);&#125;</code></pre><p>将“&#x2F;&#x2F;print details”这段代码放到独立函数当中，并让函数名解释用途。</p><pre><code class="java">void printOwing(double amount) &#123;        printBanner();        //print details        printDetails(amount);&#125;void printDetails(double amount)&#123;        System.out.println(&quot;....&quot;);        System.out.println(&quot;....&quot; + amount);&#125;</code></pre><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>简短且命名良好的函数：</p><ul><li>颗粒度小，被复用的机会就更大</li><li>使高层函数读起来像一系列注释</li><li>覆写更容易</li></ul><h1 id="2-Inline-Method（内联函数）"><a href="#2-Inline-Method（内联函数）" class="headerlink" title="2. Inline Method（内联函数）"></a>2. Inline Method（内联函数）</h1><blockquote><p>在函数调用点插入函数本体，然后移除该函数</p></blockquote><pre><code class="java">int getRating() &#123;    return (moreThanFiveLateDeliveries()) ? 2 : 1;&#125;boolean moreThanFiveLateDeliveries()&#123;    return _numberOfLateDeliveries &gt; 5;&#125;</code></pre><pre><code class="java">int getRating() &#123;    return _numberOfLateDeliveries &gt; 5 ? 2 : 1;&#125;</code></pre><h2 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h2><ul><li>非必要的间接性让人不舒服</li><li>如果有一群不合理的函数，可以先将它们内联到一个大型函数当中，再从中提炼出合理的小函数。</li><li>使用了太多间接层。找出有用的间接层，将无用的间接层去除。</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>如果具备多态特性，子类重写了该函数，不要将函数进行内联</li></ul><h1 id="3-Inline-Temp（内联临时变量）"><a href="#3-Inline-Temp（内联临时变量）" class="headerlink" title="3. Inline Temp（内联临时变量）"></a>3. Inline Temp（内联临时变量）</h1><blockquote><p>将所有对该变量的引用动作，替换为对它赋值的那个表达式自身。</p></blockquote><pre><code class="java">double basePrice = anOrder.basePrice();return (basePrice &gt; 1000)</code></pre><pre><code class="java">return anOrder.basePrice() &gt; 1000</code></pre><h2 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h2><ul><li>某个临时变量被赋予某个函数的返回值</li></ul><h1 id="4-Replace-Temp-with-Query（以查询取代临时变量）"><a href="#4-Replace-Temp-with-Query（以查询取代临时变量）" class="headerlink" title="4. Replace Temp with Query（以查询取代临时变量）"></a>4. Replace Temp with Query（以查询取代临时变量）</h1><blockquote><p>将这个临时变量的引用点替换为对新函数的调用。</p></blockquote><pre><code class="java">double basePrice = _quantity * _itemPrice;if (basePrice &gt; 1000)    return basePrice * 0.95;else     return basePrice * 0.98;</code></pre><pre><code class="java">if (basePrice() &gt; 1000)    return basePrice() * 0.95;else     return basePrice() * 0.98;double basePrice()&#123;    return _quantity * _itemPrice;&#125;</code></pre><h2 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h2><ul><li>临时变量替换为一个查询，那么同一个类中的所有函数都将可以获得这个信息。</li></ul><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><ul><li>找出只被赋值一次的临时变量</li></ul><h1 id="5-Introduce-Explaining-Variable（引入解释性变量）"><a href="#5-Introduce-Explaining-Variable（引入解释性变量）" class="headerlink" title="5. Introduce Explaining Variable（引入解释性变量）"></a>5. Introduce Explaining Variable（引入解释性变量）</h1><blockquote><p>将该复杂表达式的结构放进一个临时变量</p></blockquote><pre><code class="java">if (platform.toUpperCase().indexOf(&quot;MAC&quot;) &gt; -1 &amp;&amp;    browser.toUpperCase().indexOf(&quot;IE&quot;) &gt; -1 &amp;&amp;    wasInitialized() &amp;&amp; resize &gt; 0 )&#123;&#125;</code></pre><pre><code class="java">final boolean isMacOs = platform.toUpperCase().indexOf(&quot;MAC&quot;) &gt; -1;final boolean isIEBrowser = browser.toUpperCase().indexOf(&quot;IE&quot;) &gt; -1;final boolean wasResized = resize &gt; 0;if (isMacOs &amp;&amp; isIEBrower &amp;&amp; wasInitialized() &amp;&amp; wasResized)&#123;&#125;</code></pre><h2 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h2><ul><li>表达式有可能非常复杂而难以阅读。临时变量可以帮助你将表达式分解</li><li>在较长算法中，可以运用临时变量来解释每一步运算的意义</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>在Extract Method 需要花费更大工作量的时候使用</li></ul><h1 id="6-Split-Temporary-Variable（分解临时变量）"><a href="#6-Split-Temporary-Variable（分解临时变量）" class="headerlink" title="6. Split Temporary Variable（分解临时变量）"></a>6. Split Temporary Variable（分解临时变量）</h1><blockquote><p>针对每次赋值，创造一个独立、对应的临时变量。</p></blockquote><pre><code class="java">double temp = 2 * (_height + _width);System.out.println(temp);temp = _height * _width;System.out.println(temp);</code></pre><pre><code class="java">final double perimeter = 2 * (_height + _width);System.out.println(perimeter);final double area = _height * _width;System.out.println(area);</code></pre><h2 id="动机-5"><a href="#动机-5" class="headerlink" title="动机"></a>动机</h2><ul><li>临时变量应该只被赋值一次。如果超过一次，就意味着它们在函数中承担了一个以上的责任。</li></ul><h1 id="7-Remove-Assignments-to-Parameters（移除对参数的赋值）"><a href="#7-Remove-Assignments-to-Parameters（移除对参数的赋值）" class="headerlink" title="7. Remove Assignments to Parameters（移除对参数的赋值）"></a>7. Remove Assignments to Parameters（移除对参数的赋值）</h1><blockquote><p>以一个临时变量取代该参数的位置</p></blockquote><pre><code class="java">int discount (int inputVal, int quantity , int yearToDate) &#123;    if (inputVal &gt; 50 ) input -= 2;</code></pre><pre><code class="java">int discount(int inputVal,int quantity,int yearToDate) &#123;    int result = inputVal;    if (inputVal &gt; 50 ) result -= 2;</code></pre><h2 id="动机-6"><a href="#动机-6" class="headerlink" title="动机"></a>动机</h2><ul><li>这样的做法，降低了代码的清晰度，而且混用了按值传递和按引用传递这两种参数传递方式</li></ul><h1 id="8-Replace-Method-with-Method-Object-（以函数对象取代函数）"><a href="#8-Replace-Method-with-Method-Object-（以函数对象取代函数）" class="headerlink" title="8. Replace Method with Method Object （以函数对象取代函数）"></a>8. Replace Method with Method Object （以函数对象取代函数）</h1><blockquote><p>将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段</p></blockquote><pre><code class="java">class Order &#123;    double price() &#123;        double primaryBasePrice;        double secondaryBasePrice;        double tertiaryBasePrice;    &#125;&#125;</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/../img/replaceMethodWithMethodObj.png" alt="replaceMethodWithMethodObj"></h2><h2 id="动机-7"><a href="#动机-7" class="headerlink" title="动机"></a>动机</h2><ul><li>局部变量的存在会增加函数分解难度</li><li>无法用Replace Temp with Query 拆解一个需要拆解的函数</li></ul><h1 id="9-Substitute-Algorithm-（替换算法）"><a href="#9-Substitute-Algorithm-（替换算法）" class="headerlink" title="9. Substitute Algorithm （替换算法）"></a>9. Substitute Algorithm （替换算法）</h1><blockquote><p>将函数本体替换为另一个算法</p></blockquote><pre><code class="java">String foundPerson(String[] people)&#123;    for (int i =0; i &lt;people.length;i++)&#123;        if (people[0].equals(&quot;Don&quot;))&#123;            return &quot;Don&quot;;        &#125;    &#125;    return &quot;&quot;;&#125;</code></pre><pre><code class="java">String foundPerson(String[] people)&#123;    List candidates = Arrays.asList(new String[]&#123;&quot;Don&quot;,&quot;John&quot;&#125;);    for (int i =0; i &lt;people.length;i++)&#123;        if (candidates.contains(people[i]))&#123;            return people[i];        &#125;    &#125;    return &quot;&quot;;&#125;</code></pre><h2 id="动机-8"><a href="#动机-8" class="headerlink" title="动机"></a>动机</h2><ul><li>在原先的做法之外，有更简单的解决方案。</li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li>《重构-改善既有代码的设计》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步-自旋锁</title>
      <link href="/2022/11/24/%E5%90%8C%E6%AD%A5-%E8%87%AA%E6%97%8B%E9%94%81/"/>
      <url>/2022/11/24/%E5%90%8C%E6%AD%A5-%E8%87%AA%E6%97%8B%E9%94%81/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> 同步 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
