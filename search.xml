<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>重新组织数据</title>
      <link href="/2023/01/25/%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E6%95%B0%E6%8D%AE/"/>
      <url>/2023/01/25/%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Self-Encapsulate-Field（自封装字段）"><a href="#1-Self-Encapsulate-Field（自封装字段）" class="headerlink" title="1. Self Encapsulate Field（自封装字段）"></a>1. Self Encapsulate Field（自封装字段）</h1><blockquote><p>为这个字段建立取值&#x2F;设值函数，并且只以这些函数来访问字段</p></blockquote><pre><code class="java">private int _low ,_high;bolean includes (int arg) &#123;  return arg &gt;= _low &amp;&amp; arg &lt;= _high;&#125;</code></pre><pre><code class="java">private int _low ,_high;bolean includes (int arg) &#123;  return arg &gt;= getLow() &amp;&amp; arg &lt;= getHigh();&#125;int getLow() &#123;return _low;&#125;int getHigh()&#123;return _high;&#125;</code></pre><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>如果想访问超类的一个字段，却又想在子类中将对这个变量的访问改为一个计算后的值。</li></ul><h1 id="2-Replace-Data-Value-with-Object-（以对象取代数据值）"><a href="#2-Replace-Data-Value-with-Object-（以对象取代数据值）" class="headerlink" title="2. Replace Data Value with Object （以对象取代数据值）"></a>2. Replace Data Value with Object （以对象取代数据值）</h1><blockquote><p>将数据项变成对象</p></blockquote><ol><li><p><img src="/../img/replaceDataValueWithObj1.png"></p></li><li><p><img src="/../img/replaceDataValueWithObj2.png"></p></li></ol><h2 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h2><ul><li>当Duplicate Code 坏味道和Feature Envy坏味道开始出现，就应该将数据值变成对象</li></ul><h1 id="3-Change-Value-to-Reference-（将值对象改为引用对象）"><a href="#3-Change-Value-to-Reference-（将值对象改为引用对象）" class="headerlink" title="3. Change Value to Reference （将值对象改为引用对象）"></a>3. Change Value to Reference （将值对象改为引用对象）</h1><blockquote><p>将这个值对象变成引用对象</p></blockquote><ol><li><p><img src="/../img/replaceDataValueWithObj2.png"></p></li><li><p><img src="/../img/changeValuetoReference.png"></p></li></ol><h2 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h2><ul><li>对对象做一个有用的分类：引用对象和值对象。</li><li>可能会希望给这个对象加入一些可修改数据，并确保对任何一个对象的修改都能影响到所有引用此一对象的地方。这个时候就要将对象变成一个引用对象。</li></ul><h1 id="4-Change-Reference-to-Value-（将引用对象改为值对象）"><a href="#4-Change-Reference-to-Value-（将引用对象改为值对象）" class="headerlink" title="4. Change Reference to Value （将引用对象改为值对象）"></a>4. Change Reference to Value （将引用对象改为值对象）</h1><blockquote><p>将它变成一个值对象</p></blockquote><ol><li><p><img src="/../img/changeValuetoReference.png"></p></li><li><p><img src="/../img/replaceDataValueWithObj2.png"></p></li></ol><h2 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h2><ul><li>引用对象开始变得难以使用，也许就应该将它改为值对象</li><li>值对象有一个非常重要的特质：不可变</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>如果无法将该对象修改为不可变的，则放弃使用本项重构</li><li>建立equals() 和 hashCode()</li></ul><h1 id="5-Replace-Array-with-Object-（以对象取代数组）"><a href="#5-Replace-Array-with-Object-（以对象取代数组）" class="headerlink" title="5. Replace Array with Object （以对象取代数组）"></a>5. Replace Array with Object （以对象取代数组）</h1><blockquote><p>以对象替换数组。对数组中的每个元素，以一个字段来表示</p></blockquote><pre><code class="java">String[] row = new String[3];row[0] = &quot;LiverPool&quot;;row[1] = &quot;15&quot;;</code></pre><pre><code class="java">Performance row = new Performance();row.setName(&quot;LiverPool&quot;);row.setWins(&quot;15&quot;);</code></pre><h2 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h2><ul><li>一个数组容纳来多种不同的对象，会给用户带来麻烦</li></ul><h1 id="6-Duplicate-Observed-Data-（复制“被监视数据”）"><a href="#6-Duplicate-Observed-Data-（复制“被监视数据”）" class="headerlink" title="6. Duplicate Observed Data （复制“被监视数据”）"></a>6. Duplicate Observed Data （复制“被监视数据”）</h1><blockquote><p>将该数据复制到一个领域对象中。建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据。</p></blockquote><ol><li><p><img src="/../img/duplicateObservedData1.png"></p></li><li></li></ol><p><img src="/../img/duplicateObservedData2.webp"></p><h2 id="动机-5"><a href="#动机-5" class="headerlink" title="动机"></a>动机</h2><ul><li>将处理用户界面和处理业务逻辑的代码分开</li></ul><h1 id="7-Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向关联）"><a href="#7-Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向关联）" class="headerlink" title="7. Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）"></a>7. Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）</h1><blockquote><p>添加一个反向指针，并使修改函数能够同时更新两条连接</p></blockquote><p>1. </p><p><img src="/../img/cuab1.webp"></p><ol start="2"><li><img src="/../img/cuab2.webp"></li></ol><h2 id="动机-6"><a href="#动机-6" class="headerlink" title="动机"></a>动机</h2><ul><li>引用类需要得到其引用者以便进行某些处理</li></ul><h1 id="8-Change-Bidirectional-Association-to-Unidirectional（将双向关联改为单向关联）"><a href="#8-Change-Bidirectional-Association-to-Unidirectional（将双向关联改为单向关联）" class="headerlink" title="8. Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）"></a>8. Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）</h1><blockquote><p>去除不必要的关联</p></blockquote><ol><li><img src="/../img/cuab2.webp"></li><li><img src="/../img/cuab1.webp"></li></ol><h2 id="动机-7"><a href="#动机-7" class="headerlink" title="动机"></a>动机</h2><ul><li>维护双向连接、确保对象被正确创建和删除，增加了复杂度</li><li>大量的双向连接很容易造成“僵尸对象”</li><li>双向关联迫使两个类之间有了依赖</li></ul><h1 id="9-Replace-Magic-Number-with-Symbolic-Constant-（以字面量取代魔法数）"><a href="#9-Replace-Magic-Number-with-Symbolic-Constant-（以字面量取代魔法数）" class="headerlink" title="9. Replace Magic Number with Symbolic Constant （以字面量取代魔法数）"></a>9. Replace Magic Number with Symbolic Constant （以字面量取代魔法数）</h1><blockquote><p>创造一个常量，根据其意义为它命名，并将上述的字面量值替换为这个常量</p></blockquote><pre><code class="java">double potentialEnergy(double mass , double height) &#123;  return mass * 9.81 * height;&#125;</code></pre><pre><code class="java">static final double GRAVITATIONAL_CONSTANT = 9.18;double potentialEnergy(double mass , double height) &#123;  return mass * GRAVITATIONAL_CONSTANT * height;&#125;</code></pre><h2 id="动机-8"><a href="#动机-8" class="headerlink" title="动机"></a>动机</h2><ul><li>魔法数是指拥有特殊意义，却又不能明确表现出这种意义的数字。一旦这些数发生改变，查找修改是一场噩梦。</li><li>常量不会造成任何性能开销，却可以大大提高代码的可读性。</li></ul><h1 id="10-Encapsulate-Field-（封装字段）"><a href="#10-Encapsulate-Field-（封装字段）" class="headerlink" title="10. Encapsulate Field （封装字段）"></a>10. Encapsulate Field （封装字段）</h1><blockquote><p>将它声明为private ，并提供相应的访问函数</p></blockquote><pre><code class="java">public String _name;</code></pre><pre><code class="java">private String _name;public String getName() &#123;  return _name;&#125;public void setName(String arg)&#123;  _name = arg;&#125;</code></pre><h2 id="动机-9"><a href="#动机-9" class="headerlink" title="动机"></a>动机</h2><ul><li>面向对象的首要原则之一就是封装，或者成为“数据隐藏”。</li><li>数据声明为public是一种不好的做法，因为这样会降低程序的模块化程度。</li></ul><h1 id="11-Encapsulate-Collection-（封装集合）"><a href="#11-Encapsulate-Collection-（封装集合）" class="headerlink" title="11. Encapsulate Collection （封装集合）"></a>11. Encapsulate Collection （封装集合）</h1><blockquote><p>让这个函数返回该集合的一个只读副本，并在这个类中提供添加&#x2F;移除集合元素的函数。</p></blockquote><ol><li><p><img src="/../img/ec1.png"></p></li><li><p><img src="/../img/ec2.png"></p></li></ol><h2 id="动机-10"><a href="#动机-10" class="headerlink" title="动机"></a>动机</h2><ul><li>取值函数不该返回集合本身，应该避免用户直接操作对象内所保存的集合，并隐藏对象内与用户无关的数据结构。</li><li>不应该为这整个集合提供一个设值函数，但应该提供集合添加&#x2F;移除元素的函数。</li></ul><h1 id="12-Replace-Record-with-Data-Class（以数据类取代记录）"><a href="#12-Replace-Record-with-Data-Class（以数据类取代记录）" class="headerlink" title="12. Replace Record with Data Class（以数据类取代记录）"></a>12. Replace Record with Data Class（以数据类取代记录）</h1><blockquote><p>为该记录创建一个“哑”数据对象。</p></blockquote><h2 id="动机-11"><a href="#动机-11" class="headerlink" title="动机"></a>动机</h2><ul><li>程序是通过一个传统API来与记录结构交流，或者处理从数据库读出的记录。这时候就需要创建一个接口类，用以处理这些外来数据。</li></ul><h1 id="13-Replace-Type-Code-with-Class-（以类取代类型码）"><a href="#13-Replace-Type-Code-with-Class-（以类取代类型码）" class="headerlink" title="13. Replace Type Code with Class （以类取代类型码）"></a>13. Replace Type Code with Class （以类取代类型码）</h1><blockquote><p>以一个新的类替换该数值类型码</p></blockquote><ol><li><p><img src="/../img/rtcc1.png"></p></li><li><p><img src="/../img/rtcc2.webp"></p></li></ol><h2 id="动机-12"><a href="#动机-12" class="headerlink" title="动机"></a>动机</h2><ul><li>任何接受类型码作为参数的函数，所期望的实际上是一个数值，无法强制使用符号名</li><li>如果将数值换成一个类，编译器就可以对这个类进行类型检验</li></ul><h1 id="14-Replace-Type-Code-with-Subclasses-（以子类取代类型码）"><a href="#14-Replace-Type-Code-with-Subclasses-（以子类取代类型码）" class="headerlink" title="14. Replace Type Code with Subclasses （以子类取代类型码）"></a>14. Replace Type Code with Subclasses （以子类取代类型码）</h1><blockquote><p>以子类取代这个类型码</p></blockquote><ol><li><p><img src="/../img/rtcs1.png"></p></li><li><p><img src="/../img/rtcs2.webp"></p></li></ol><pre><code class="java">static Employee create(int type) &#123;  switch(type) &#123;    case ENGINEER :      return new Engineer();    case SALESMAN:      return new Salesman();    default :        throw new IllegalArgumentException(&quot;Incorrect type code value&quot;);    &#125;&#125;</code></pre><h2 id="动机-13"><a href="#动机-13" class="headerlink" title="动机"></a>动机</h2><ul><li>如果类型码影响宿主类的行为，那么最好的办法就是借助多态来处理变化行为</li><li>一般这种情况的标志就是像switch这样的条件表达式</li></ul><h1 id="15-Replace-Type-Code-with-State-x2F-Strategy-（以State-x2F-Strategy取代类型码）"><a href="#15-Replace-Type-Code-with-State-x2F-Strategy-（以State-x2F-Strategy取代类型码）" class="headerlink" title="15. Replace Type Code with State&#x2F;Strategy （以State&#x2F;Strategy取代类型码）"></a>15. Replace Type Code with State&#x2F;Strategy （以State&#x2F;Strategy取代类型码）</h1><blockquote><p>以状态对象取代类型码</p></blockquote><ol><li><p><img src="/../img/rtcs1.png"></p></li><li><p><img src="/../img/rtcss.webp"></p></li></ol><h2 id="动机-14"><a href="#动机-14" class="headerlink" title="动机"></a>动机</h2><ul><li>如果“类型码的值在对象生命周期中发生变化” 或 “其他原因使得宿主类不能被继承”，可以使用本重构</li><li>本重构使用State模式（状态模式）或Strategy模式（策略模式）</li></ul><h1 id="16-Replace-Subclass-with-Fields-（以字段取代子类）"><a href="#16-Replace-Subclass-with-Fields-（以字段取代子类）" class="headerlink" title="16. Replace Subclass with Fields （以字段取代子类）"></a>16. Replace Subclass with Fields （以字段取代子类）</h1><blockquote><p>修改这些函数，使它们返回超类中的某个（新增）字段，然后销毁子类</p></blockquote><ol><li><p><img src="/../img/rsf1.webp"></p></li><li></li></ol><p><img src="/../img/rsf2.png"></p><h2 id="动机-15"><a href="#动机-15" class="headerlink" title="动机"></a>动机</h2><ul><li>建立子类的目的是为了增加新特性或变化其行为。有一种变化行为成为“常量函数”，会返回一个硬编码的值。</li><li>若子类中只有常量函数，实在没有足够的存在价值。可以去除这样的子类，避免因继承而带来的额外复杂性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在对象之间搬移特性</title>
      <link href="/2023/01/23/%E5%9C%A8%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E6%90%AC%E7%A7%BB%E7%89%B9%E6%80%A7/"/>
      <url>/2023/01/23/%E5%9C%A8%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E6%90%AC%E7%A7%BB%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在对象的设计过程中，“决定把责任放在哪儿” 即使不是最重要的事，也是最重要的事之一。</p></blockquote><h1 id="1-Move-Method（搬移函数）"><a href="#1-Move-Method（搬移函数）" class="headerlink" title="1. Move Method（搬移函数）"></a>1. Move Method（搬移函数）</h1><blockquote><p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是将旧函数完全移除。</p></blockquote><p><img src="/../img/moveMethod1.png"></p><p><img src="/../img/moveMethod2.png"></p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>如果一个类有太多行为，或如果一个类与另一个类有太多合作而形成高度耦合，就搬移函数。</li><li>使用另一个对象的次数比使用自己所驻对象的次数还多。</li></ul><h1 id="2-Move-Field（搬移字段）"><a href="#2-Move-Field（搬移字段）" class="headerlink" title="2. Move Field（搬移字段）"></a>2. Move Field（搬移字段）</h1><blockquote><p>在目标类新建一个字段，修改源字段的所有用户，令它们改用新字段。</p></blockquote><p><img src="/../img/moveField1.png"></p><p><img src="/../img/moveField2.png"></p><h2 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h2><ul><li>对于一个字段，在其所驻类之外的另一个类中有更多函数使用了它，就会考虑搬移这个字段。</li></ul><h1 id="3-Extract-Class（提炼类）"><a href="#3-Extract-Class（提炼类）" class="headerlink" title="3. Extract Class（提炼类）"></a>3. Extract Class（提炼类）</h1><blockquote><p>建立一个新类，将相关的字段和函数从旧类搬移到新类。</p></blockquote><p><img src="/../img/extractClass1.png"></p><p><img src="/../img/extractClass2.png"></p><h2 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h2><ul><li>一个类应该是一个清楚的抽象，处理一些明确的责任</li><li>类含有大量函数和数据</li><li>开发后期出现的信号是类的子类化方式</li></ul><h1 id="4-Inline-Class-（将类内联化）"><a href="#4-Inline-Class-（将类内联化）" class="headerlink" title="4. Inline Class （将类内联化）"></a>4. Inline Class （将类内联化）</h1><blockquote><p>将这个类的所有特性搬移到另一个类中，然后移除原类</p></blockquote><ol><li></li></ol><p><img src="/../img/extractClass2.png"></p><ol start="2"><li></li></ol><p><img src="/../img/extractClass1.png"></p><h2 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h2><ul><li>如果一个类不再承担足够责任、不再有单独存在的理由</li></ul><h1 id="5-Hide-Delegate-（隐藏“委托关系”）"><a href="#5-Hide-Delegate-（隐藏“委托关系”）" class="headerlink" title="5. Hide Delegate （隐藏“委托关系”）"></a>5. Hide Delegate （隐藏“委托关系”）</h1><blockquote><p>在服务类上建立客户所需的所有函数，用以隐藏委托关系</p></blockquote><ol><li></li></ol><p><img src="/../img/hideDelegate1.png"></p><ol start="2"><li><img src="/../img/hideDelegate2.png"></li></ol><h2 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h2><ul><li>“封装”意味着每个对象都应该尽可能少了解系统的其他部分。</li><li>万一委托关系发生变化，客户也得相应变化。将委托关系隐藏起来，从而去除这种依赖。</li></ul><h1 id="6-Remove-Middle-Man-（移除中间人）"><a href="#6-Remove-Middle-Man-（移除中间人）" class="headerlink" title="6. Remove Middle Man （移除中间人）"></a>6. Remove Middle Man （移除中间人）</h1><blockquote><p>让客户直接调用受委托类</p></blockquote><ol><li><p><img src="/../img/hideDelegate2.png"></p></li><li><p><img src="/../img/hideDelegate1.png"></p></li></ol><h2 id="动机-5"><a href="#动机-5" class="headerlink" title="动机"></a>动机</h2><ul><li>“封装受委托对象”要付出代价： 每当客户要使用委托类的新特性时，你就必须在服务端添加一个简单的委托函数。随着受委托的特性越来越多，服务类完全变成了一个“中间人”。</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>也可能想保留一部分委托关系。希望对某些客户隐藏委托关系，对另一些用户直接使用委托关系。</li></ul><h1 id="7-Introduce-Foreign-Method（引入外加函数）"><a href="#7-Introduce-Foreign-Method（引入外加函数）" class="headerlink" title="7. Introduce Foreign Method（引入外加函数）"></a>7. Introduce Foreign Method（引入外加函数）</h1><blockquote><p>在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。</p></blockquote><pre><code class="java">Date newStart = new Date(previousEnd.getYear(),previousEnd.getMonth(),previousEnd.getDate()+1);</code></pre><pre><code class="java">Date newStart = nextDate(previousEnd);private static Date nextDate(Date arg) &#123;  // foreign method, should be on date  return new Date(arg.getYear(),arg.getMonth(),arg.getDate()+1);&#125;</code></pre><h2 id="动机-6"><a href="#动机-6" class="headerlink" title="动机"></a>动机</h2><ul><li>需要一项新的服务，这个类无法供应</li><li>明确信号：这个函数原本应该在提供服务的类中实现</li></ul><h1 id="8-Introduce-Local-Extension-（引入本地扩展）"><a href="#8-Introduce-Local-Extension-（引入本地扩展）" class="headerlink" title="8. Introduce Local Extension （引入本地扩展）"></a>8. Introduce Local Extension （引入本地扩展）</h1><blockquote><p>建立一个新类，使它包含这些额外函数。让其成为源类的子类或者包装类</p></blockquote><ol><li><img src="/../img/introduceLocalExtension1.png"></li><li><img src="/../img/introduceLocalExtension2.png"></li></ol><h2 id="动机-7"><a href="#动机-7" class="headerlink" title="动机"></a>动机</h2><ul><li>需要的额外函数超过两个，外加函数很难控制。需要将这些函数组织在一起，放到恰当的地方</li><li>要达到这一目的，两种标准对象技术—— 子类化（subclassing）和包装（wrapping）——统称本地扩展（local extension)</li></ul><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><ul><li>一般来说，不在扩展类中重写原始类的函数，只会添加新函数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重新组织函数</title>
      <link href="/2023/01/20/%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E5%87%BD%E6%95%B0/"/>
      <url>/2023/01/20/%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>几乎所有时刻，问题都源于Long Method(过长函数)</p></blockquote><h1 id="1-Extract-Method-提炼函数"><a href="#1-Extract-Method-提炼函数" class="headerlink" title="1. Extract Method(提炼函数)"></a>1. Extract Method(提炼函数)</h1><pre><code class="java">void printOwing(double amount) &#123;        printBanner();                //print details        System.out.println(&quot;....&quot;);        System.out.println(&quot;....&quot; + amount);&#125;</code></pre><p>将“&#x2F;&#x2F;print details”这段代码放到独立函数当中，并让函数名解释用途。</p><pre><code class="java">void printOwing(double amount) &#123;        printBanner();        //print details        printDetails(amount);&#125;void printDetails(double amount)&#123;        System.out.println(&quot;....&quot;);        System.out.println(&quot;....&quot; + amount);&#125;</code></pre><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>简短且命名良好的函数：</p><ul><li>颗粒度小，被复用的机会就更大</li><li>使高层函数读起来像一系列注释</li><li>覆写更容易</li></ul><h1 id="2-Inline-Method（内联函数）"><a href="#2-Inline-Method（内联函数）" class="headerlink" title="2. Inline Method（内联函数）"></a>2. Inline Method（内联函数）</h1><blockquote><p>在函数调用点插入函数本体，然后移除该函数</p></blockquote><pre><code class="java">int getRating() &#123;    return (moreThanFiveLateDeliveries()) ? 2 : 1;&#125;boolean moreThanFiveLateDeliveries()&#123;    return _numberOfLateDeliveries &gt; 5;&#125;</code></pre><pre><code class="java">int getRating() &#123;    return _numberOfLateDeliveries &gt; 5 ? 2 : 1;&#125;</code></pre><h2 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h2><ul><li>非必要的间接性让人不舒服</li><li>如果有一群不合理的函数，可以先将它们内联到一个大型函数当中，再从中提炼出合理的小函数。</li><li>使用了太多间接层。找出有用的间接层，将无用的间接层去除。</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>如果具备多态特性，子类重写了该函数，不要将函数进行内联</li></ul><h1 id="3-Inline-Temp（内联临时变量）"><a href="#3-Inline-Temp（内联临时变量）" class="headerlink" title="3. Inline Temp（内联临时变量）"></a>3. Inline Temp（内联临时变量）</h1><blockquote><p>将所有对该变量的引用动作，替换为对它赋值的那个表达式自身。</p></blockquote><pre><code class="java">double basePrice = anOrder.basePrice();return (basePrice &gt; 1000)</code></pre><pre><code class="java">return anOrder.basePrice() &gt; 1000</code></pre><h2 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h2><ul><li>某个临时变量被赋予某个函数的返回值</li></ul><h1 id="4-Replace-Temp-with-Query（以查询取代临时变量）"><a href="#4-Replace-Temp-with-Query（以查询取代临时变量）" class="headerlink" title="4. Replace Temp with Query（以查询取代临时变量）"></a>4. Replace Temp with Query（以查询取代临时变量）</h1><blockquote><p>将这个临时变量的引用点替换为对新函数的调用。</p></blockquote><pre><code class="java">double basePrice = _quantity * _itemPrice;if (basePrice &gt; 1000)    return basePrice * 0.95;else     return basePrice * 0.98;</code></pre><pre><code class="java">if (basePrice() &gt; 1000)    return basePrice() * 0.95;else     return basePrice() * 0.98;double basePrice()&#123;    return _quantity * _itemPrice;&#125;</code></pre><h2 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h2><ul><li>临时变量替换为一个查询，那么同一个类中的所有函数都将可以获得这个信息。</li></ul><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><ul><li>找出只被赋值一次的临时变量</li></ul><h1 id="5-Introduce-Explaining-Variable（引入解释性变量）"><a href="#5-Introduce-Explaining-Variable（引入解释性变量）" class="headerlink" title="5. Introduce Explaining Variable（引入解释性变量）"></a>5. Introduce Explaining Variable（引入解释性变量）</h1><blockquote><p>将该复杂表达式的结构放进一个临时变量</p></blockquote><pre><code class="java">if (platform.toUpperCase().indexOf(&quot;MAC&quot;) &gt; -1 &amp;&amp;    browser.toUpperCase().indexOf(&quot;IE&quot;) &gt; -1 &amp;&amp;    wasInitialized() &amp;&amp; resize &gt; 0 )&#123;&#125;</code></pre><pre><code class="java">final boolean isMacOs = platform.toUpperCase().indexOf(&quot;MAC&quot;) &gt; -1;final boolean isIEBrowser = browser.toUpperCase().indexOf(&quot;IE&quot;) &gt; -1;final boolean wasResized = resize &gt; 0;if (isMacOs &amp;&amp; isIEBrower &amp;&amp; wasInitialized() &amp;&amp; wasResized)&#123;&#125;</code></pre><h2 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h2><ul><li>表达式有可能非常复杂而难以阅读。临时变量可以帮助你将表达式分解</li><li>在较长算法中，可以运用临时变量来解释每一步运算的意义</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>在Extract Method 需要花费更大工作量的时候使用</li></ul><h1 id="6-Split-Temporary-Variable（分解临时变量）"><a href="#6-Split-Temporary-Variable（分解临时变量）" class="headerlink" title="6. Split Temporary Variable（分解临时变量）"></a>6. Split Temporary Variable（分解临时变量）</h1><blockquote><p>针对每次赋值，创造一个独立、对应的临时变量。</p></blockquote><pre><code class="java">double temp = 2 * (_height + _width);System.out.println(temp);temp = _height * _width;System.out.println(temp);</code></pre><pre><code class="java">final double perimeter = 2 * (_height + _width);System.out.println(perimeter);final double area = _height * _width;System.out.println(area);</code></pre><h2 id="动机-5"><a href="#动机-5" class="headerlink" title="动机"></a>动机</h2><ul><li>临时变量应该只被赋值一次。如果超过一次，就意味着它们在函数中承担了一个以上的责任。</li></ul><h1 id="7-Remove-Assignments-to-Parameters（移除对参数的赋值）"><a href="#7-Remove-Assignments-to-Parameters（移除对参数的赋值）" class="headerlink" title="7. Remove Assignments to Parameters（移除对参数的赋值）"></a>7. Remove Assignments to Parameters（移除对参数的赋值）</h1><blockquote><p>以一个临时变量取代该参数的位置</p></blockquote><pre><code class="java">int discount (int inputVal, int quantity , int yearToDate) &#123;    if (inputVal &gt; 50 ) input -= 2;</code></pre><pre><code class="java">int discount(int inputVal,int quantity,int yearToDate) &#123;    int result = inputVal;    if (inputVal &gt; 50 ) result -= 2;</code></pre><h2 id="动机-6"><a href="#动机-6" class="headerlink" title="动机"></a>动机</h2><ul><li>这样的做法，降低了代码的清晰度，而且混用了按值传递和按引用传递这两种参数传递方式</li></ul><h1 id="8-Replace-Method-with-Method-Object-（以函数对象取代函数）"><a href="#8-Replace-Method-with-Method-Object-（以函数对象取代函数）" class="headerlink" title="8. Replace Method with Method Object （以函数对象取代函数）"></a>8. Replace Method with Method Object （以函数对象取代函数）</h1><blockquote><p>将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段</p></blockquote><pre><code class="java">class Order &#123;    double price() &#123;        double primaryBasePrice;        double secondaryBasePrice;        double tertiaryBasePrice;    &#125;&#125;</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/../img/replaceMethodWithMethodObj.png" alt="replaceMethodWithMethodObj"></h2><h2 id="动机-7"><a href="#动机-7" class="headerlink" title="动机"></a>动机</h2><ul><li>局部变量的存在会增加函数分解难度</li><li>无法用Replace Temp with Query 拆解一个需要拆解的函数</li></ul><h1 id="9-Substitute-Algorithm-（替换算法）"><a href="#9-Substitute-Algorithm-（替换算法）" class="headerlink" title="9. Substitute Algorithm （替换算法）"></a>9. Substitute Algorithm （替换算法）</h1><blockquote><p>将函数本体替换为另一个算法</p></blockquote><pre><code class="java">String foundPerson(String[] people)&#123;    for (int i =0; i &lt;people.length;i++)&#123;        if (people[0].equals(&quot;Don&quot;))&#123;            return &quot;Don&quot;;        &#125;    &#125;    return &quot;&quot;;&#125;</code></pre><pre><code class="java">String foundPerson(String[] people)&#123;    List candidates = Arrays.asList(new String[]&#123;&quot;Don&quot;,&quot;John&quot;&#125;);    for (int i =0; i &lt;people.length;i++)&#123;        if (candidates.contains(people[i]))&#123;            return people[i];        &#125;    &#125;    return &quot;&quot;;&#125;</code></pre><h2 id="动机-8"><a href="#动机-8" class="headerlink" title="动机"></a>动机</h2><ul><li>在原先的做法之外，有更简单的解决方案。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步-自旋锁</title>
      <link href="/2022/11/24/%E5%90%8C%E6%AD%A5-%E8%87%AA%E6%97%8B%E9%94%81/"/>
      <url>/2022/11/24/%E5%90%8C%E6%AD%A5-%E8%87%AA%E6%97%8B%E9%94%81/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> 同步 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
