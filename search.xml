<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>快速地改善代码质量的20条编程规范</title>
      <link href="/2023/02/05/%E5%BF%AB%E9%80%9F%E5%9C%B0%E6%94%B9%E5%96%84%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%8420%E6%9D%A1%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
      <url>/2023/02/05/%E5%BF%AB%E9%80%9F%E5%9C%B0%E6%94%B9%E5%96%84%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%8420%E6%9D%A1%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最应该关注、最好用的编码规范，分为三个大的方面：命名与注释（Naming and Comments）、代码风格（Code Style）、编程技巧（Coding Tips）。</p></blockquote><h1 id="命名与注释（Naming-and-Comments）"><a href="#命名与注释（Naming-and-Comments）" class="headerlink" title="命名与注释（Naming and Comments）"></a>命名与注释（Naming and Comments）</h1><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><h3 id="1-命名多长最合适？"><a href="#1-命名多长最合适？" class="headerlink" title="1. 命名多长最合适？"></a>1. 命名多长最合适？</h3><p>实际上，在足够表达其含义的情况下，命名当然是越短越好。</p><p>对于一些默认的、大家都比较熟知的词，我比较推荐用缩写。这样一方面能让命名短一些，另一方面又不影响阅读理解，比如，sec 表示 second、str 表示 string、num 表示 number、doc 表示 document。</p><p>除此之外，对于作用域比较小的变量，我们可以使用相对短的命名，比如一些函数内的临时变量。相反，对于类名这种作用域比较大的，我更推荐用长的命名方式。</p><p><strong>总之，命名的一个原则就是以能准确达意为目标。</strong></p><h3 id="2-利用上下文简化命名"><a href="#2-利用上下文简化命名" class="headerlink" title="2. 利用上下文简化命名"></a>2. 利用上下文简化命名</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String userName;</span><br><span class="line">  <span class="keyword">private</span> String userPassword;</span><br><span class="line">  <span class="keyword">private</span> String userAvatarUrl;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 User 类这样一个上下文中，我们没有在成员变量的命名中重复添加“user”这样一个前缀单词，而是直接命名为 name、password、avatarUrl</p><h3 id="3-命名要可读、可搜索"><a href="#3-命名要可读、可搜索" class="headerlink" title="3. 命名要可读、可搜索"></a>3. 命名要可读、可搜索</h3><p>首先，我们来看，什么是命名可读。先解释一下，我这里所说的“可读”，指的是<strong>不要用一些特别生僻、难发音的英文单词来命名</strong>。</p><p>我们再来讲一下命名可搜索。我们在 IDE 中编写代码的时候，经常会用<strong>“关键词联想”的方法来自动补全和搜索</strong>。</p><h3 id="4-如何命名接口和抽象类？"><a href="#4-如何命名接口和抽象类？" class="headerlink" title="4. 如何命名接口和抽象类？"></a>4. 如何命名接口和抽象类？</h3><p>对于<strong>接口的命名</strong>，一般有两种比较常见的方式。一种是加<strong>前缀“I”</strong>，表示一个 Interface。比如 IUserService，对应的实现类命名为 UserService。另一种是不加前缀，比如 UserService，对应的实现类加后缀“Impl”，比如 UserServiceImpl。</p><p>对于<strong>抽象类的命名</strong>，也有两种方式，一种是带上<strong>前缀“Abstract”</strong>，比如 AbstractConfiguration；另一种是不带前缀“Abstract”。实际上，对于接口和抽象类，选择哪种命名方式都是可以的，只要项目里能够统一就行。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="1-注释到底该写什么？"><a href="#1-注释到底该写什么？" class="headerlink" title="1. 注释到底该写什么？"></a>1. 注释到底该写什么？</h3><p>注释的目的就是让代码更容易看懂。只要符合这个要求的内容，你就可以将它写到注释里。总结一下，注释的内容主要包含这样三个方面：做什么、为什么、怎么做。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* (what) Bean factory to create beans. </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* (why) The class likes Spring IOC framework, but is more lightweight. </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* (how) Create objects from different sources sequentially:</span></span><br><span class="line"><span class="comment">* user specified object &gt; SPI &gt; configuration &gt; default object.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeansFactory</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注释比代码承载的信息更多</li><li>注释起到总结性作用、文档的作用</li><li>一些总结性注释能让代码结构更清晰</li></ul><h3 id="2-注释是不是越多越好？"><a href="#2-注释是不是越多越好？" class="headerlink" title="2. 注释是不是越多越好？"></a>2. 注释是不是越多越好？</h3><p>注释太多和太少都有问题。太多，有可能意味着代码写得不够可读，需要写很多注释来补充。</p><p>按照我的经验来说，<strong>类和函数一定要写注释，而且要写得尽可能全面、详细</strong>，而函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码的可读性。</p><h1 id="代码风格（Code-Style）"><a href="#代码风格（Code-Style）" class="headerlink" title="代码风格（Code Style）"></a>代码风格（Code Style）</h1><h2 id="1-类、函数多大才合适？"><a href="#1-类、函数多大才合适？" class="headerlink" title="1. 类、函数多大才合适？"></a>1. 类、函数多大才合适？</h2><p>总体上来讲，类或函数的代码行数不能太多，但也不能太少。</p><p>那一个类或函数有多少行代码才最合适呢？</p><p>对于函数代码行数的最大限制，网上有一种说法，那就是<strong>不要超过一个显示屏的垂直高度</strong>。</p><p>对于类的代码行数的最大限制，这个就更难给出一个确切的值了。</p><p>当一个类的代码读起来让你感觉头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能要引入整个类（类中包含很多无关此功能实现的函数）的时候，这就说明类的行数过多了。</p><h2 id="2-一行代码多长最合适？"><a href="#2-一行代码多长最合适？" class="headerlink" title="2. 一行代码多长最合适？"></a>2. 一行代码多长最合适？</h2><p>在Google Java Style Guide文档中，一行代码最长限制为 100 个字符。</p><p>不管这个限制是多少，总体上来讲我们要遵循的一个原则是：<strong>一行代码最长不能超过 IDE 显示的宽度</strong>。需要滚动鼠标才能查看一行的全部代码，显然不利于代码的阅读。</p><h2 id="3-善用空行分割单元块"><a href="#3-善用空行分割单元块" class="headerlink" title="3. 善用空行分割单元块"></a>3. 善用空行分割单元块</h2><p>对于比较长的函数，如果逻辑上可以分为几个独立的代码块，在不方便将这些独立的代码块抽取成小函数的情况下，为了让逻辑更加清晰，除了上一节课中提到的用总结性注释的方法之外，我们还可以使用空行来分割各个代码块。</p><p>除此之外，在类的成员变量与函数之间、静态成员变量与普通成员变量之间、各函数之间、甚至各成员变量之间，我们都可以<strong>通过添加空行的方式，让这些不同模块的代码之间，界限更加明确。</strong></p><h2 id="4-四格缩进还是两格缩进？"><a href="#4-四格缩进还是两格缩进？" class="headerlink" title="4. 四格缩进还是两格缩进？"></a>4. 四格缩进还是两格缩进？</h2><p>据我所知，Java 语言倾向于两格缩进，PHP 语言倾向于四格缩进。至于到底应该是两格缩进还是四格缩进，我觉得这个取决于个人喜好。只要项目内部能够统一就行了。</p><p>当然，还有一个选择的标准，那就是跟业内推荐的风格统一、跟著名开源项目统一。</p><p>除此之外，值得强调的是，<strong>不管是用两格缩进还是四格缩进，一定不要用 tab 键缩进</strong>。因为在不同的 IDE 下，tab 键的显示宽度不同，有的显示为四格缩进，有的显示为两格缩进。</p><h2 id="5-大括号是否要另起一行？"><a href="#5-大括号是否要另起一行？" class="headerlink" title="5. 大括号是否要另起一行？"></a>5. 大括号是否要另起一行？</h2><p>左大括号是否要另起一行呢？这个也有争论。据我所知，PHP 程序员喜欢另起一行，Java 程序员喜欢跟上一条语句放到一起。</p><p>我个人还是比较推荐，将括号放到跟语句同一行的风格。理由跟上面类似，节省代码行数。</p><h2 id="6-类中成员的排列顺序"><a href="#6-类中成员的排列顺序" class="headerlink" title="6. 类中成员的排列顺序"></a>6. 类中成员的排列顺序</h2><p>在 Java 类文件中，先要书写类所属的包名，然后再罗列 import 引入的依赖类。<strong>在 Google 编码规范中，依赖类按照字母序从小到大排列。</strong></p><p>在类中，成员变量排在函数的前面。成员变量之间或函数之间，都是按照“先静态（静态函数或静态成员变量）、后普通（非静态函数或非静态成员变量）”的方式来排列的。</p><p>除此之外，成员变量之间或函数之间，还会按照作用域范围从大到小的顺序来排列，先写 public 成员变量或函数，然后是 protected 的，最后是 private 的。</p><p>实际上，还有另外一种排列习惯，那就是把有调用关系的函数放到一块。比如，一个 public 函数调用了另外一个 private 函数，那就把这两者放到一块。</p><h1 id="编程技巧（Coding-Tips）"><a href="#编程技巧（Coding-Tips）" class="headerlink" title="编程技巧（Coding Tips）"></a>编程技巧（Coding Tips）</h1><h2 id="1-把代码分割成更小的单元块"><a href="#1-把代码分割成更小的单元块" class="headerlink" title="1. 把代码分割成更小的单元块"></a>1. 把代码分割成更小的单元块</h2><p>大部分人阅读代码的习惯都是，先看整体再看细节。所以，我们要有模块化和抽象思维，善于将大块的复杂逻辑提炼成类或者函数，屏蔽掉细节，让阅读代码的人不至于迷失在细节中，这样能极大地提高代码的可读性。</p><h2 id="2-避免函数参数过多"><a href="#2-避免函数参数过多" class="headerlink" title="2. 避免函数参数过多"></a>2. 避免函数参数过多</h2><p>我个人觉得，函数包含 3、4 个参数的时候还是能接受的，大于等于 5 个的时候，我们就觉得参数有点过多了，会影响到代码的可读性，使用起来也不方便。</p><ul><li><p>考虑函数是否职责单一，是否能通过拆分成多个函数的方式来减少参数。示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(String username, String telephone, String email)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆分成多个函数</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserByUsername</span><span class="params">(String username)</span>;</span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserByTelephone</span><span class="params">(String telephone)</span>;</span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserByEmail</span><span class="params">(String email)</span>;</span><br></pre></td></tr></table></figure></li><li><p>将函数的参数封装成对象。示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postBlog</span><span class="params">(String title, String summary, String keywords, String content, String category, <span class="type">long</span> authorId)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将参数封装成对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Blog</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String title;</span><br><span class="line">  <span class="keyword">private</span> String summary;</span><br><span class="line">  <span class="keyword">private</span> String keywords;</span><br><span class="line">  <span class="keyword">private</span> Strint content;</span><br><span class="line">  <span class="keyword">private</span> String category;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> authorId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postBlog</span><span class="params">(Blog blog)</span>;</span><br></pre></td></tr></table></figure></li></ul><p>除此之外，如果函数是对外暴露的远程接口，将参数封装成对象，还可以提高接口的兼容性。在往接口中添加新的参数的时候，老的远程接口调用者有可能就不需要修改代码来兼容新的接口了。</p><h2 id="3-勿用函数参数来控制逻辑"><a href="#3-勿用函数参数来控制逻辑" class="headerlink" title="3. 勿用函数参数来控制逻辑"></a>3. 勿用函数参数来控制逻辑</h2><p>不要在函数中使用布尔类型的标识参数来控制内部逻辑，true 的时候走这块逻辑，false 的时候走另一块逻辑。这明显违背了单一职责原则和接口隔离原则。我建议将其拆成两个函数，可读性上也要更好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyCourse</span><span class="params">(<span class="type">long</span> userId, <span class="type">long</span> courseId, <span class="type">boolean</span> isVip)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将其拆分成两个函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyCourse</span><span class="params">(<span class="type">long</span> userId, <span class="type">long</span> courseId)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyCourseForVip</span><span class="params">(<span class="type">long</span> userId, <span class="type">long</span> courseId)</span>;</span><br></pre></td></tr></table></figure><p>不过，如果函数是 private 私有函数，影响范围有限，或者拆分之后的两个函数经常同时被调用，我们可以酌情考虑保留标识参数。</p><p>除了布尔类型作为标识参数来控制逻辑的情况外，还有一种“根据参数是否为 null”来控制逻辑的情况。针对这种情况，我们也应该将其拆分成多个函数。拆分之后的函数职责更明确，不容易用错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Transaction&gt; <span class="title function_">selectTransactions</span><span class="params">(Long userId, Date startDate, Date endDate)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (startDate != <span class="literal">null</span> &amp;&amp; endDate != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 查询两个时间区间的transactions</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (startDate != <span class="literal">null</span> &amp;&amp; endDate == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 查询startDate之后的所有transactions</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (startDate == <span class="literal">null</span> &amp;&amp; endDate != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 查询endDate之前的所有transactions</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (startDate == <span class="literal">null</span> &amp;&amp; endDate == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 查询所有的transactions</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆分成多个public函数，更加清晰、易用</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Transaction&gt; <span class="title function_">selectTransactionsBetween</span><span class="params">(Long userId, Date startDate, Date endDate)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> selectTransactions(userId, startDate, endDate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;Transaction&gt; <span class="title function_">selectTransactionsStartWith</span><span class="params">(Long userId, Date startDate)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> selectTransactions(userId, startDate, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;Transaction&gt; <span class="title function_">selectTransactionsEndWith</span><span class="params">(Long userId, Date endDate)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> selectTransactions(userId, <span class="literal">null</span>, endDate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;Transaction&gt; <span class="title function_">selectAllTransactions</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> selectTransactions(userId, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Transaction&gt; <span class="title function_">selectTransactions</span><span class="params">(Long userId, Date startDate, Date endDate)</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-函数设计要职责单一"><a href="#4-函数设计要职责单一" class="headerlink" title="4. 函数设计要职责单一"></a>4. 函数设计要职责单一</h2><p>我们在前面讲到单一职责原则的时候，针对的是类、模块这样的应用对象。实际上，对于函数的设计来说，更要满足单一职责原则。相对于类和模块，函数的粒度比较小，代码行数少，所以在应用单一职责原则的时候，没有像应用到类或者模块那样模棱两可，能多单一就多单一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkUserIfExisting</span><span class="params">(String telephone, String username, String email)</span>  &#123; </span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.isBlank(telephone)) &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRepo.selectUserByTelephone(telephone);</span><br><span class="line">    <span class="keyword">return</span> user != <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.isBlank(username)) &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRepo.selectUserByUsername(username);</span><br><span class="line">    <span class="keyword">return</span> user != <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.isBlank(email)) &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRepo.selectUserByEmail(email);</span><br><span class="line">    <span class="keyword">return</span> user != <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆分成三个函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkUserIfExistingByTelephone</span><span class="params">(String telephone)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkUserIfExistingByUsername</span><span class="params">(String username)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkUserIfExistingByEmail</span><span class="params">(String email)</span>;</span><br></pre></td></tr></table></figure><h2 id="5-移除过深的嵌套层次"><a href="#5-移除过深的嵌套层次" class="headerlink" title="5. 移除过深的嵌套层次"></a>5. 移除过深的嵌套层次</h2><p>代码嵌套层次过深往往是因为 if-else、switch-case、for 循环过度嵌套导致的。我个人建议，嵌套最好不超过两层，超过两层之后就要思考一下是否可以减少嵌套。</p><ul><li>去掉多余的 if 或 else 语句。</li><li>使用编程语言提供的 continue、break、return 关键字，提前退出嵌套</li><li>调整执行顺序来减少嵌套</li><li>将部分嵌套逻辑封装成函数调用，以此来减少嵌套</li></ul><p>除此之外，常用的还有通过使用多态来替代 if-else、switch-case 条件判断的方法。</p><h2 id="6-学会使用解释性变量"><a href="#6-学会使用解释性变量" class="headerlink" title="6. 学会使用解释性变量"></a>6. 学会使用解释性变量</h2><ul><li><p>常量取代魔法数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">CalculateCircularArea</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">3.1415</span>) * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量替代魔法数字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.1415</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">CalculateCircularArea</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> PI * radius * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用解释性变量来解释复杂表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (date.after(SUMMER_START) &amp;&amp; date.before(SUMMER_END)) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入解释性变量后逻辑更加清晰</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isSummer</span> <span class="operator">=</span> date.after(SUMMER_START)&amp;&amp;date.before(SUMMER_END);</span><br><span class="line"><span class="keyword">if</span> (isSummer) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li>《设计模式之美》</li></ul><p><img src="/../img/geek1.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重构列表-大型重构</title>
      <link href="/2023/02/04/%E5%A4%A7%E5%9E%8B%E9%87%8D%E6%9E%84/"/>
      <url>/2023/02/04/%E5%A4%A7%E5%9E%8B%E9%87%8D%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>对于这些大型重构，有一件事需要注意：它们会耗费相当长的时间。</p><p>在这个过程中，应该根据需要安排自己的工作，只在需要添加新功能或者修复错误的时候才进行重构。</p><p>重构的程度只要能满足其他任务的需要就行了。</p></blockquote><h1 id="1-Tease-Apart-Inheritance-（梳理并分解继承体系）"><a href="#1-Tease-Apart-Inheritance-（梳理并分解继承体系）" class="headerlink" title="1. Tease Apart Inheritance （梳理并分解继承体系）"></a>1. Tease Apart Inheritance （梳理并分解继承体系）</h1><blockquote><p>某个继承体系同时承担两项责任。</p><p>建立两个继承体系，并通过委托关系让其中一个可以调用另外一个。</p></blockquote><ol><li><p><img src="/../img/tai1.png"></p></li><li><p><img src="/../img/tai2.png"></p></li></ol><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>混乱的继承体系是一个严重的问题，因为会导致重复代码，使修改变得困难。</li><li>判断继承体系是否承担了两种不同的责任： 如果继承体系中的某一特定层级上的所有类，其子类名称都以相同的形容词开始，那么这个体系很可能就承担着两项不同的责任。</li></ul><h1 id="2-Convert-Procedural-Design-to-Objects-（将过程化设计转化为对象设计）"><a href="#2-Convert-Procedural-Design-to-Objects-（将过程化设计转化为对象设计）" class="headerlink" title="2. Convert Procedural Design to Objects （将过程化设计转化为对象设计）"></a>2. Convert Procedural Design to Objects （将过程化设计转化为对象设计）</h1><blockquote><p>手上有一些传统过程化风格的代码。</p><p>将数据记录变成对象，将大块的行为分成小块，并将行为移入相关对象之中。</p></blockquote><ol><li><p><img src="/../img/cpdo1.png"></p></li><li><p><img src="/../img/cpdo2.png"></p></li></ol><h2 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h2><ul><li>类中有着长长的过程化函数和极少的数据，旁边则是一堆哑数据对象——除了数据访问函数外没有其他任何函数。</li></ul><h1 id="3-Separate-Domain-from-Presentation（将领域和表述-x2F-显示分离）"><a href="#3-Separate-Domain-from-Presentation（将领域和表述-x2F-显示分离）" class="headerlink" title="3. Separate Domain from Presentation（将领域和表述&#x2F;显示分离）"></a>3. Separate Domain from Presentation（将领域和表述&#x2F;显示分离）</h1><blockquote><p>某些GUI类之中包含了领域逻辑。</p><p>将领域逻辑分离出来，为它们建立独立的领域类(model)。</p></blockquote><ol><li><p><img src="/../img/sdp1.png"></p></li><li><p><img src="/../img/sdp2.png"></p></li></ol><h2 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h2><ul><li>将用户界面代码和领域逻辑分离。领域类不含任何与程序外观相关的代码，只含业务逻辑相关代码。</li></ul><h1 id="4-Extract-Hierarchy（提炼继承体系）"><a href="#4-Extract-Hierarchy（提炼继承体系）" class="headerlink" title="4. Extract Hierarchy（提炼继承体系）"></a>4. Extract Hierarchy（提炼继承体系）</h1><blockquote><p>你有某个类做了太多工作，其中一部分工作是以大量条件表达式完成的。</p><p>建立继续体系，以一个子类表示一种特殊情况。</p></blockquote><ol><li><p><img src="/../img/eh1.png"></p></li><li><p><img src="/../img/eh2.png"></p></li></ol><h2 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h2><ul><li>随着设计方案的演化，最后一个类实现了两个、三个乃至十个不同的概念。</li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li>《重构-改善既有代码的设计》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重构列表-处理概括关系(继承关系)</title>
      <link href="/2023/02/03/%E5%A4%84%E7%90%86%E6%A6%82%E6%8B%AC%E5%85%B3%E7%B3%BB/"/>
      <url>/2023/02/03/%E5%A4%84%E7%90%86%E6%A6%82%E6%8B%AC%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>有一批重构手法专门用来处理类的概括关系（generalization，即继承关系），其中主要是将函数上下移动于继承体系之中。</p></blockquote><h1 id="1-Pull-Up-Field（字段上移）"><a href="#1-Pull-Up-Field（字段上移）" class="headerlink" title="1. Pull Up Field（字段上移）"></a>1. Pull Up Field（字段上移）</h1><blockquote><p>两个子类拥有相同的字段。</p><p>将该字段移至超类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empolyee</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Salesman</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engineer</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empolyee</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Salesman</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engineer</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>去除了重复的数据声明</li><li>该字段的行为从子类移动到超类，从而去除重复行为</li></ul><h1 id="2-Pull-Up-Method（函数上移）"><a href="#2-Pull-Up-Method（函数上移）" class="headerlink" title="2. Pull Up Method（函数上移）"></a>2. Pull Up Method（函数上移）</h1><blockquote><p>有些函数，在各个子类中产生完全相同的结果。</p><p>将函数移至超类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empolyee</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Salesman</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engineer</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empolyee</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Salesman</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engineer</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h2><ul><li>避免行为重复</li></ul><h1 id="3-Pull-Up-Constructor-Body（构造函数本体上移）"><a href="#3-Pull-Up-Constructor-Body（构造函数本体上移）" class="headerlink" title="3. Pull Up Constructor Body（构造函数本体上移）"></a>3. Pull Up Constructor Body（构造函数本体上移）</h1><blockquote><p>你在各个子类中拥有一些构造函数，它们的本体几乎完全一致。</p><p>在超类中新建一个构造函数，并在子类构造函数中调用它</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String name,String id,<span class="type">int</span> grade)</span> &#123;</span><br><span class="line">    _name = name;</span><br><span class="line">    _id = id;</span><br><span class="line">    _grade = grade;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SalesManager</span> <span class="keyword">extends</span> <span class="title class_">Manager</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">SalesManager</span><span class="params">(String name,String id,<span class="type">int</span> grade)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name,id,grade);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h2><ul><li>如果看见各个子类中的函数有共同行为，第一个念头应该是将共同行为提炼到一个独立函数中，然后将这个函数提升到超类。</li></ul><h1 id="4-Push-Down-Method（函数下移）"><a href="#4-Push-Down-Method（函数下移）" class="headerlink" title="4. Push Down Method（函数下移）"></a>4. Push Down Method（函数下移）</h1><blockquote><p>超类中的某个函数只与部分（而非全部）子类有关。</p><p>将这个函数移到相关的那些子类去。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">getQuota</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Salesman</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engineer</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Salesman</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getQuota</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engineer</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h2><ul><li>当有必要把某些行为从超类移至特定的子类时。</li></ul><h1 id="5-Push-Down-Field（字段下移）"><a href="#5-Push-Down-Field（字段下移）" class="headerlink" title="5. Push Down Field（字段下移）"></a>5. Push Down Field（字段下移）</h1><blockquote><p>超类中的某个字段只被部分（而非全部）子类用到。</p><p>将这个字段移到需要它的那些子类去。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> String quota;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Salesman</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engineer</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Salesman</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String quota;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engineer</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h2><ul><li>如果只有某些（而非全部）子类需要超类内的一个字段，你可以使用本项重构。</li></ul><h1 id="6-Extract-Subclass（提炼子类）"><a href="#6-Extract-Subclass（提炼子类）" class="headerlink" title="6. Extract Subclass（提炼子类）"></a>6. Extract Subclass（提炼子类）</h1><blockquote><p>类中的某些特性只被某些（而非全部）实例用到。</p><p>新建一个子类，将上面所说的那一部分特性移到子类中。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JobItem</span> &#123;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">getTotalPrice</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">getUnitPrice</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  Employee <span class="title function_">getEmployee</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JobItem</span> &#123;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">getTotalPrice</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">getUnitPrice</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  Employee <span class="title function_">getEmployee</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LaborItem</span> <span class="keyword">extends</span> <span class="title class_">JobItem</span> &#123;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">getUnitPrice</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  Employee <span class="title function_">getEmployee</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="动机-5"><a href="#动机-5" class="headerlink" title="动机"></a>动机</h2><ul><li>发现类中的某些行为只被一部分实例用到，其他实例不需要它们。</li></ul><h1 id="7-Extract-Superclass（提炼超类）"><a href="#7-Extract-Superclass（提炼超类）" class="headerlink" title="7. Extract Superclass（提炼超类）"></a>7. Extract Superclass（提炼超类）</h1><blockquote><p>两个类有相似特性。</p><p>为这两个类建立一个超类，将相同特性移至超类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Department</span> &#123;</span><br><span class="line">  String <span class="title function_">getTotalAnnualCost</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  String <span class="title function_">getName</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">getHeadCount</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  String <span class="title function_">getTotalAnnualCost</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  String <span class="title function_">getName</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Party</span> &#123;</span><br><span class="line">  String <span class="title function_">getTotalAnnualCost</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  String <span class="title function_">getName</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Department</span> <span class="keyword">extends</span> <span class="title class_">Party</span>&#123;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">getHeadCount</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_">Party</span>&#123;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动机-6"><a href="#动机-6" class="headerlink" title="动机"></a>动机</h2><ul><li>重复代码是系统中最糟糕的东西之一。</li><li>两个类以相同的方式做类似的事情，或者以不同的方式做类似的事情。</li></ul><h1 id="8-Extract-Interface-（提炼接口）"><a href="#8-Extract-Interface-（提炼接口）" class="headerlink" title="8. Extract Interface （提炼接口）"></a>8. Extract Interface （提炼接口）</h1><blockquote><p>若干客户使用类接口中的同一子集，或者两个类的接口有部分相同。</p><p>将相同的子集提炼到一个独立接口中。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">getRate</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">hasSpecialSkill</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  String <span class="title function_">getName</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  String <span class="title function_">getDepartment</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Billable</span> &#123;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">getRate</span><span class="params">()</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">hasSpecialSkill</span><span class="params">()</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Billable</span> &#123;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">getRate</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">hasSpecialSkill</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  String <span class="title function_">getName</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  String <span class="title function_">getDepartment</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="动机-7"><a href="#动机-7" class="headerlink" title="动机"></a>动机</h2><ul><li>将真正用到的这部分责任分离出来通常很有意义，因为这样可以使系统的用法更清晰，同时也更容易看清系统的责任划分。</li></ul><h1 id="9-Collapse-Hierarchy（折叠继承体系）"><a href="#9-Collapse-Hierarchy（折叠继承体系）" class="headerlink" title="9. Collapse Hierarchy（折叠继承体系）"></a>9. Collapse Hierarchy（折叠继承体系）</h1><blockquote><p>超类和子类之间无太大区别。</p><p>将它们合为一体。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Salesman</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="动机-8"><a href="#动机-8" class="headerlink" title="动机"></a>动机</h2><ul><li>发现某个子类并未带来该有的价值，因此需要把超类与子类合并起来。</li></ul><h1 id="10-Form-Template-Method（塑造模板函数）"><a href="#10-Form-Template-Method（塑造模板函数）" class="headerlink" title="10. Form Template Method（塑造模板函数）"></a>10. Form Template Method（塑造模板函数）</h1><blockquote><p>你有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节上有所不同。</p><p>将这些操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同了。然后将原函数上移至超类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Site</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResidentialSite</span> <span class="keyword">extends</span> <span class="title class_">Site</span> &#123;</span><br><span class="line">  String <span class="title function_">getBillableAmount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">base</span> <span class="operator">=</span> _units * _rate;</span><br><span class="line">    <span class="type">double</span> <span class="variable">tax</span> <span class="operator">=</span> base * Site.TAX_RATE;</span><br><span class="line">    <span class="keyword">return</span> base + tax;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LifelineSite</span> <span class="keyword">extends</span> <span class="title class_">Site</span> &#123;</span><br><span class="line">  String <span class="title function_">getBillableAmount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">base</span> <span class="operator">=</span> _units * _rate * <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">tax</span> <span class="operator">=</span> base * Site.TAX_RATE * <span class="number">0.2</span>;</span><br><span class="line">    <span class="keyword">return</span> base + tax;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Site</span> &#123;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">getBillableAmount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getBaseAmount() + getTaxAmount();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">getBaseAmount</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">getTaxAmount</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResidentialSite</span> <span class="keyword">extends</span> <span class="title class_">Site</span> &#123;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">getBaseAmount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _units * _rate;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">getTaxAmount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> base * Site.TAX_RATE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LifelineSite</span> <span class="keyword">extends</span> <span class="title class_">Site</span> &#123;</span><br><span class="line">   <span class="type">double</span> <span class="title function_">getBaseAmount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _units * _rate * <span class="number">0.5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">getTaxAmount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> base * Site.TAX_RATE * <span class="number">0.2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="动机-9"><a href="#动机-9" class="headerlink" title="动机"></a>动机</h2><ul><li>两个函数以相同顺序执行大致相近的操作，但是各操作不完全相同。</li></ul><h1 id="11-Replace-Inheritance-with-Delegation（以委托取代继承）"><a href="#11-Replace-Inheritance-with-Delegation（以委托取代继承）" class="headerlink" title="11. Replace Inheritance with Delegation（以委托取代继承）"></a>11. Replace Inheritance with Delegation（以委托取代继承）</h1><blockquote><p>某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据。</p><p>在子类中新建一个字段用以保存超类；</p><p>调整子类函数，令它改而委托超类；</p><p>然后去掉两者之间的继承关系。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> <span class="keyword">extends</span> <span class="title class_">Vector</span> &#123;  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Vector</span> <span class="variable">_vector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _vector.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动机-10"><a href="#动机-10" class="headerlink" title="动机"></a>动机</h2><ul><li>以委托取代继承，可以更清楚表明：只需要受托类的一部分功能。</li></ul><h1 id="12-Replace-Delegation-with-Inheritance-（以继承取代委托）"><a href="#12-Replace-Delegation-with-Inheritance-（以继承取代委托）" class="headerlink" title="12. Replace Delegation with Inheritance （以继承取代委托）"></a>12. Replace Delegation with Inheritance （以继承取代委托）</h1><blockquote><p>你在两个类之间使用委托关系，并经常为整个接口编写许多极简单的委托函数。</p><p>让委托类继承受托类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  String <span class="title function_">getName</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">  </span><br><span class="line">  String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> person.getName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  String <span class="title function_">getName</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动机-11"><a href="#动机-11" class="headerlink" title="动机"></a>动机</h2><ul><li>如果发现需要使用受委托类中的所有函数，并且费了很大力气编写所有极简的委托函数。</li></ul><h2 id="告诫"><a href="#告诫" class="headerlink" title="告诫"></a>告诫</h2><ul><li>并没有使用受托类的<strong>所有函数</strong>，那么就不使用本重构</li><li>受托对象被不止一个其他对象共享，而且受托对象是可变的。</li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li>《重构-改善既有代码的设计》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重构列表-简化函数调用</title>
      <link href="/2023/02/01/%E7%AE%80%E5%8C%96%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"/>
      <url>/2023/02/01/%E7%AE%80%E5%8C%96%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>容易被理解和被使用的**接口(interface)**，是开发良好面向对象软件的关键。</p></blockquote><h1 id="1-Rename-Method（函数改名）"><a href="#1-Rename-Method（函数改名）" class="headerlink" title="1. Rename Method（函数改名）"></a>1. Rename Method（函数改名）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">  String <span class="title function_">getinvcdtlmt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">  String <span class="title function_">getInvoiceableCreditLimit</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>将复杂的处理过程分解成小函数是一种好的编程风格，要弄清楚这些小函数的各自的用途，关键在于给函数起一个好名称。</li><li>给函数命名有一个好办法：首先考虑应该给这个函数写上一句怎样的注释，然后想办法将注释变成函数名称。</li></ul><h1 id="2-Add-Parameter（添加参数）"><a href="#2-Add-Parameter（添加参数）" class="headerlink" title="2. Add Parameter（添加参数）"></a>2. Add Parameter（添加参数）</h1><blockquote><p>某个函数需要从调用端得到更多信息</p><p>为此函数添加一个对象参数，让该对象带进函数所需信息。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">  String <span class="title function_">getContact</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">  String <span class="title function_">getContact</span><span class="params">(Date date)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h2><ul><li>必须修改一个函数，而修改后的函数需要一些过去没有的信息，因此需要给该函数添加一个参数</li><li>不使用本重构的时机：除了添加参数外，还有其他选择</li></ul><h1 id="3-Remove-Parameter（移除参数）"><a href="#3-Remove-Parameter（移除参数）" class="headerlink" title="3. Remove Parameter（移除参数）"></a>3. Remove Parameter（移除参数）</h1><blockquote><p>函数本体不再需要某个参数。</p><p>将该参数去除</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">  String <span class="title function_">getContact</span><span class="params">(Date date)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">  String <span class="title function_">getContact</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h2><ul><li>不去掉多余参数，函数调用者必须为每一个参数操心。</li></ul><h1 id="4-Separate-Query-from-Modifier（将查询函数和修改函数分离）"><a href="#4-Separate-Query-from-Modifier（将查询函数和修改函数分离）" class="headerlink" title="4. Separate Query from Modifier（将查询函数和修改函数分离）"></a>4. Separate Query from Modifier（将查询函数和修改函数分离）</h1><blockquote><p>某个函数既返回对象状态值，又修改对象状态</p><p>建立两个不同的函数，其中一个负责查询，另一个负责修改</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">  String <span class="title function_">getTotalOutstandingAndSetReadyForSummaries</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">  String <span class="title function_">getTotalOutstanding</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">setReadyForSummaries</span><span class="params">(String data)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h2><ul><li>任何有返回值的函数，都不应该有看得到的副作用。</li><li>“既有返回值又有副作用”的函数，就应该试着将查询动作从修改动作中分割出来。</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>并发问题</li></ul><h1 id="5-Parameterize-Method（令函数携带参数）"><a href="#5-Parameterize-Method（令函数携带参数）" class="headerlink" title="5. Parameterize Method（令函数携带参数）"></a>5. Parameterize Method（令函数携带参数）</h1><blockquote><p>若干函数做了类似的工作，但在函数本体中却包含了不同的值。</p><p>建立单一函数，以参数表达那些不同的值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">fivePercentRaise</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">tenPercentRaise</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">raise</span><span class="params">(<span class="type">double</span> percentage)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h2><ul><li>可能会发现这样的两个函数：做着类似的工作，但因少数几个值导致行为不同。</li><li>重点：以“可将少量数值视为参数”为依据，找出带有重复性的代码。</li></ul><h1 id="6-Replace-Parameter-with-Explicit-Methods（以明确函数取代参数）"><a href="#6-Replace-Parameter-with-Explicit-Methods（以明确函数取代参数）" class="headerlink" title="6. Replace Parameter with Explicit Methods（以明确函数取代参数）"></a>6. Replace Parameter with Explicit Methods（以明确函数取代参数）</h1><blockquote><p>你有一个函数，其中完全取决于参数值而采取不同行为。</p><p>针对该参数的每一个可能值，建立一个独立函数。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(String name,<span class="type">int</span> value)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (name.equals(<span class="string">&quot;height&quot;</span>))&#123;</span><br><span class="line">    _height = value;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (name.equals(<span class="string">&quot;width&quot;</span>)) &#123;</span><br><span class="line">    _width = value;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Assert.shouldNeverReachHere();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setHeight</span><span class="params">(<span class="type">int</span> arg)</span>&#123;</span><br><span class="line">  _height = arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setWidth</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">  _width = arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动机-5"><a href="#动机-5" class="headerlink" title="动机"></a>动机</h2><ul><li>如果某个参数有多种可能的值，而函数内又以条件表达式检查这些参数，并根据不同参数值做出不同的行为，那么就应该使用本项重构。</li><li>如果参数值不会对函数行为有太多影响，就不应该使用本项重构。</li></ul><h1 id="7-Preserve-Whole-Object-（保持对象完整）"><a href="#7-Preserve-Whole-Object-（保持对象完整）" class="headerlink" title="7. Preserve Whole Object （保持对象完整）"></a>7. Preserve Whole Object （保持对象完整）</h1><blockquote><p>你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。</p><p>改为传递整个对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> daysTempRange().getLow();</span><br><span class="line"><span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> daysTempRange().getHigh();</span><br><span class="line">withinPlan = plan.withinRange(low,high);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">withinPlan = plan.withinRange(daysTempRange());</span><br></pre></td></tr></table></figure><h2 id="动机-6"><a href="#动机-6" class="headerlink" title="动机"></a>动机</h2><ul><li>万一将来被调用函数需要新的数据项，你就必须查找并修改对此函数的所有调用。</li><li>过长的参数列表难使用，调用者必须记住这些参数的用途。</li></ul><h1 id="8-Replace-Parameter-with-Methods（以函数取代参数）"><a href="#8-Replace-Parameter-with-Methods（以函数取代参数）" class="headerlink" title="8. Replace Parameter with Methods（以函数取代参数）"></a>8. Replace Parameter with Methods（以函数取代参数）</h1><blockquote><p>对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数本身也能够调用前一个函数。</p><p>让参数接受者去除该项参数，并直接调用前一个函数。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">basePrice</span> <span class="operator">=</span> _quantity * _itemPrice;</span><br><span class="line">discountLevel = getDiscountLevel();</span><br><span class="line"><span class="type">double</span> <span class="variable">finalPrice</span> <span class="operator">=</span> discountedPrice(basePrice,discountLevel);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">basePrice</span> <span class="operator">=</span> _quantity * _itemPrice;</span><br><span class="line"><span class="type">double</span> <span class="variable">finalPrice</span> <span class="operator">=</span> discountedPrice(basePrice);</span><br></pre></td></tr></table></figure><h2 id="动机-7"><a href="#动机-7" class="headerlink" title="动机"></a>动机</h2><ul><li>如果函数可以通过其他途径获得参数值，那么就不应该通过参数取得该值。</li><li>缩减参数列的办法之一就是：看看参数接受端是否可以通过与调用端相同的计算来取得参数值。</li></ul><h1 id="9-Introduce-Parameter-Object-（引入参数对象）"><a href="#9-Introduce-Parameter-Object-（引入参数对象）" class="headerlink" title="9. Introduce Parameter Object （引入参数对象）"></a>9. Introduce Parameter Object （引入参数对象）</h1><blockquote><p>某些参数总是自然地同时出现。</p><p>以一个对象取代这些参数。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">amountInvoicedIn</span><span class="params">(start: Date,end : Date)</span>&#123;&#125;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">amountReceivedIn</span><span class="params">(start: Date,end : Date)</span>&#123;&#125;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">amountOverdueIn</span><span class="params">(start: Date,end : Date)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">amountInvoicedIn</span><span class="params">(range: DateRange)</span>&#123;&#125;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">amountReceivedIn</span><span class="params">(range: DateRange)</span>&#123;&#125;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">amountOverdueIn</span><span class="params">(range: DateRange)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动机-8"><a href="#动机-8" class="headerlink" title="动机"></a>动机</h2><ul><li>把这些参数组织到一起后，往往很快可以发现一些可被移至新建类的行为。</li></ul><h1 id="10-Remove-Setting-Method（移除设值函数）"><a href="#10-Remove-Setting-Method（移除设值函数）" class="headerlink" title="10. Remove Setting Method（移除设值函数）"></a>10. Remove Setting Method（移除设值函数）</h1><blockquote><p>类中的某个字段应该在对象创建时被设值，然后就<strong>不再改变</strong>。</p><p>去掉该字段的所有设置函数。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="comment">//去掉</span></span><br><span class="line">  <span class="comment">//void setImmutableValue(int arg)&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动机-9"><a href="#动机-9" class="headerlink" title="动机"></a>动机</h2><ul><li>如果不希望对象创建后，此字段还有机会被改变，那就不要为它提供设置函数（同时将该字段设为final）</li></ul><h1 id="11-Hide-Method（隐藏函数）"><a href="#11-Hide-Method（隐藏函数）" class="headerlink" title="11. Hide Method（隐藏函数）"></a>11. Hide Method（隐藏函数）</h1><blockquote><p>有一个函数，从来没有被其他任何类用到</p><p>将这个函数修改为<strong>private</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aMethod</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">aMethod</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动机-10"><a href="#动机-10" class="headerlink" title="动机"></a>动机</h2><ul><li>当面对一个过于丰富、提供了过多行为的接口时，就值得将非必要的取值函数和设值函数隐藏起来。</li></ul><h1 id="12-Replace-Constructor-with-Factory-Method（以工厂函数取代构造函数）"><a href="#12-Replace-Constructor-with-Factory-Method（以工厂函数取代构造函数）" class="headerlink" title="12. Replace Constructor with Factory Method（以工厂函数取代构造函数）"></a>12. Replace Constructor with Factory Method（以工厂函数取代构造函数）</h1><blockquote><p>你希望在创建对象时不仅仅是做简单的建构动作。</p><p><strong>将构造函数替换为工厂函数。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee(<span class="type">int</span> type) &#123;</span><br><span class="line">  _type = type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Employee <span class="title function_">create</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动机-11"><a href="#动机-11" class="headerlink" title="动机"></a>动机</h2><ul><li>最显而易见的动机：在派生子类的过程中以工厂函数取代类型码。</li><li>创建名单中如果还得加上子类，那些子类也是根据类型码来创建。</li></ul><h1 id="13-Encapsulate-Downcast-（封装向下转型）"><a href="#13-Encapsulate-Downcast-（封装向下转型）" class="headerlink" title="13. Encapsulate Downcast （封装向下转型）"></a>13. Encapsulate Downcast （封装向下转型）</h1><blockquote><p>某个函数返回的对象，需要由函数调用者执行向下转型（downcast)。</p><p><strong>将向下转型动作移到函数中。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">lastReading</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> readings.lastElement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Reading <span class="title function_">lastReading</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (Reading)readings.lastElement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动机-12"><a href="#动机-12" class="headerlink" title="动机"></a>动机</h2><ul><li>由于计算对象类型往往比较麻烦，你还是常常需要告诉编译器对象的确切类型。</li></ul><h1 id="14-Replace-Error-Code-with-Exception-（以异常取代错误码）"><a href="#14-Replace-Error-Code-with-Exception-（以异常取代错误码）" class="headerlink" title="14. Replace Error Code with Exception （以异常取代错误码）"></a>14. Replace Error Code with Exception （以异常取代错误码）</h1><blockquote><p>某个函数返回一个特定的代码，用以表示某种错误的情况。</p><p>改用异常。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (amount &gt; _balance)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    _balance -= amount;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">int</span> amount)</span> thows BalanceException &#123;</span><br><span class="line">  <span class="keyword">if</span> (amount &gt; _balance) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BalanceException</span>();</span><br><span class="line">  _balance -= amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动机-13"><a href="#动机-13" class="headerlink" title="动机"></a>动机</h2><ul><li>如果程序比较重要，就需要以更认真的方式来处理。</li><li>更好的错误处理方式：异常。 将“普通程序” 和 “错误处理”分开了，这使得程序更容易理解。</li></ul><h1 id="15-Replace-Exception-with-Test（以测试取代异常）"><a href="#15-Replace-Exception-with-Test（以测试取代异常）" class="headerlink" title="15. Replace Exception with Test（以测试取代异常）"></a>15. Replace Exception with Test（以测试取代异常）</h1><blockquote><p>面对一个调用者可以预先检查的条件，你抛出了一个异常。</p><p>修改调用者，使它在调用函数之前先做检查。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">getValueForPeriod</span><span class="params">(<span class="type">int</span> periodNumber)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _values[periodNumber];</span><br><span class="line">  &#125;<span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">getValueForPeriod</span><span class="params">(<span class="type">int</span> periodNumber)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (periodNumber &gt;= _values.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> _values[periodNumber];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动机-14"><a href="#动机-14" class="headerlink" title="动机"></a>动机</h2><ul><li>“异常”只应该被用于异常的、罕见的行为，也就少那些产生意料之外的错误的行为，而不应该成为条件检查的替代品。</li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li>《重构-改善既有代码的设计》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重构列表-简化条件表达式</title>
      <link href="/2023/01/31/%E7%AE%80%E5%8C%96%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2023/01/31/%E7%AE%80%E5%8C%96%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Decompose-Conditional（分解条件表达式）"><a href="#1-Decompose-Conditional（分解条件表达式）" class="headerlink" title="1. Decompose Conditional（分解条件表达式）"></a>1. Decompose Conditional（分解条件表达式）</h1><blockquote><p>你有一个复杂的条件（if-then-else）语句</p><p>从if、then、else三个段落中分别提炼出独立函数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (data.before(SUMMER_START) || data.after(SUMMER_END)) &#123;</span><br><span class="line">  charge = quantity * _winterRate + _winterServiceChange;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  charge = quantity * _summerRate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (notSummer(data))</span><br><span class="line">  charge = winterCharge(quantity);</span><br><span class="line"><span class="keyword">else</span> charge = summerCharge(quantity);</span><br></pre></td></tr></table></figure><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>大型函数自身就会使代码的可读性下降，而条件逻辑则会使代码更难阅读</li><li>将每个分支条件分解成新函数的好处：可以突出条件逻辑，更清楚地表明每个分支的作用，并且突出每个分支的原因。</li></ul><h1 id="2-Consolidate-Conditional-Expression（合并条件表达式）"><a href="#2-Consolidate-Conditional-Expression（合并条件表达式）" class="headerlink" title="2. Consolidate Conditional Expression（合并条件表达式）"></a>2. Consolidate Conditional Expression（合并条件表达式）</h1><blockquote><p>有一系列条件测试，都得到<strong>相同的结果</strong></p><p>将这些测试合并为一个条件表达式，并将这个条件表达式提炼成为一个独立函数。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">disabilityAmount</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (_seniority &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (_monthsDisabled &gt; <span class="number">12</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (_isPartTime) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">disabilityAmount</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isNotEligibleForDisability()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h2><ul><li>合并后的条件代码会让检查的用意更清晰。</li><li>这项重构往往可以为你使用Extract Method做好准备。</li></ul><h1 id="3-Consolidate-Duplicate-Conditional-Fragments（合并重复的条件片段）"><a href="#3-Consolidate-Duplicate-Conditional-Fragments（合并重复的条件片段）" class="headerlink" title="3. Consolidate Duplicate Conditional Fragments（合并重复的条件片段）"></a>3. Consolidate Duplicate Conditional Fragments（合并重复的条件片段）</h1><blockquote><p>在条件表达式的每个分支上有着相同的一段代码</p><p>将这段重复代码搬移到条件表达式之外</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isSpecialDeal()) &#123;</span><br><span class="line">  total = price * <span class="number">0.95</span>;</span><br><span class="line">  send();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  total = price * <span class="number">0.98</span>;</span><br><span class="line">  send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isSpecialDeal()) &#123;</span><br><span class="line">  total = price * <span class="number">0.95</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  total = price * <span class="number">0.98</span>;</span><br><span class="line">&#125;</span><br><span class="line">send();</span><br></pre></td></tr></table></figure><h2 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h2><ul><li>所有分支都执行了相同的某段代码，将这段代码搬到条件表达式的外面。这样，代码才能更清楚地表明哪些东西随条件的变化而变化、哪些东西保持不变。</li></ul><h1 id="4-Remove-Control-Flag-（移除控制标记）"><a href="#4-Remove-Control-Flag-（移除控制标记）" class="headerlink" title="4. Remove Control Flag （移除控制标记）"></a>4. Remove Control Flag （移除控制标记）</h1><blockquote><p>在一系列布尔表达式中，某个变量带有“控制标记”（control flag）的作用。</p><p><strong>以break语句或return语句取代控制标记。</strong></p></blockquote><h2 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="keyword">done</span> <span class="keyword">to</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">not</span> <span class="keyword">done</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line"><span class="keyword">do</span> something</span><br><span class="line"><span class="built_in">set</span> <span class="keyword">done</span> <span class="keyword">to</span> <span class="literal">true</span></span><br><span class="line">next step <span class="keyword">of</span> loop</span><br></pre></td></tr></table></figure><p>这样的控制标记带来的麻烦超过了它所带来的便利。</p><p>结构化编程原则告诉他们： 每个子程序只能有一个入口和一个出口。</p><p>“单一出口”原则会让你在代码中加入讨厌的控制标记，大大降低条件表达式的可读性。</p><h1 id="5-Replace-Nested-Conditional-with-Guard-Clauses（卫语句取代嵌套条件表达式）"><a href="#5-Replace-Nested-Conditional-with-Guard-Clauses（卫语句取代嵌套条件表达式）" class="headerlink" title="5. Replace Nested Conditional with Guard Clauses（卫语句取代嵌套条件表达式）"></a>5. Replace Nested Conditional with Guard Clauses（卫语句取代嵌套条件表达式）</h1><blockquote><p>函数中的条件逻辑使人难以看清楚正常的执行路径。</p><p>使用卫语句表现所有特殊情况。</p><ul><li>如果条件极其罕见，就应该单独检查条件，并在该条件为真的时候，从函数中返回。这样单独检查常常被称为“卫语句”(guard clauses)</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">getPayAmount</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">double</span> result;</span><br><span class="line">  <span class="keyword">if</span> (_isDead) result = deadAmount();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> (_isSeparated) result = separatedAmount();</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isRetired) result = retiredAmount();</span><br><span class="line">      <span class="keyword">else</span> result = normalPayAmount();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">getPayAmount</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isDead) <span class="keyword">return</span> deadAmount();</span><br><span class="line">  <span class="keyword">if</span> (_isSeparated) <span class="keyword">return</span> separatedAmount();</span><br><span class="line">  <span class="keyword">if</span> (_isRetired) <span class="keyword">return</span> retiredAmount();</span><br><span class="line">  <span class="keyword">return</span> normalPayAmount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h2><ul><li>精髓：给某一个条件分支以特别的重视</li></ul><h1 id="6-Replace-Conditional-with-Polymorphism（以多态取代条件表达式）"><a href="#6-Replace-Conditional-with-Polymorphism（以多态取代条件表达式）" class="headerlink" title="6. Replace Conditional with Polymorphism（以多态取代条件表达式）"></a>6. Replace Conditional with Polymorphism（以多态取代条件表达式）</h1><blockquote><p>你手上有个条件表达式，它根据对象类型的不同而选择不同的行为。</p><p>将这个条件表达式的每一个分支放进一个子类内的重写函数中，然后将原始函数声明为抽象函数。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">getSpeed</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> EUROPEAN :</span><br><span class="line">      <span class="keyword">return</span> getBaseSpeed();</span><br><span class="line">    <span class="keyword">case</span> AFRICAN:</span><br><span class="line">      <span class="keyword">return</span> getBaseSpeed()-getLoadFactor() * _numberOfCoconuts;</span><br><span class="line">    <span class="keyword">case</span> NORWEGIAN_BLUE:</span><br><span class="line">      <span class="keyword">return</span> (_isNailed)? <span class="number">0</span> : getBaseSpeed(_voltage);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Should be unreachable&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">getSpeed</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">switch</span>(_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> EUROPEAN :</span><br><span class="line">          <span class="keyword">return</span> European().getSpeed();</span><br><span class="line">        <span class="keyword">case</span> AFRICAN:</span><br><span class="line">          <span class="keyword">return</span> African().getSpeed();</span><br><span class="line">        <span class="keyword">case</span> NORWEGIAN_BLUE:</span><br><span class="line">          <span class="keyword">return</span> NorwegianBlue().getSpeed();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Should be unreachable&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">European</span> <span class="keyword">extends</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">getSpeed</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getBaseSpeed();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">African</span> <span class="keyword">extends</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">getSpeed</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getBaseSpeed()-getLoadFactor() * _numberOfCoconuts;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NorwegianBlue</span> <span class="keyword">extends</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">getSpeed</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (_isNailed)? <span class="number">0</span> : getBaseSpeed(_voltage);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="动机-5"><a href="#动机-5" class="headerlink" title="动机"></a>动机</h2><ul><li>多态最根本的好处就是：如果你需要根据对象的不同类型而采取不同的行为，多态使你不必编写明显的条件表达式。</li><li>如果同一组条件表达式在程序许多地点出现，那么使用多态的收益是最大的。</li></ul><h1 id="7-Introduce-Null-Object（引入Null对象）"><a href="#7-Introduce-Null-Object（引入Null对象）" class="headerlink" title="7. Introduce Null Object（引入Null对象）"></a>7. Introduce Null Object（引入Null对象）</h1><blockquote><p>你需要再三检查某对象是否为null</p><p>将null值替换为null对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (customer == <span class="literal">null</span>) plan = BillingPlan.basic();</span><br><span class="line"><span class="keyword">else</span> plan = customer.getPlan();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Nullable</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">isNull</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NullCustomer</span> <span class="keyword">extends</span> <span class="title class_">Customer</span> <span class="keyword">implements</span> <span class="title class_">Nullable</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNull</span><span class="params">()</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> <span class="keyword">implements</span> <span class="title class_">Nullable</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNull</span><span class="params">()</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> Customer <span class="title function_">newNull</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NullCustomer</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Site</span> &#123;</span><br><span class="line">  <span class="comment">// 不返回Null,而是返回一个NullCustomer对象</span></span><br><span class="line">  Customer <span class="title function_">getCustomer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (_customer == <span class="literal">null</span>)? Customer.newNull() : _customer;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (customer.isNull()) plan = BillingPlan.basic();</span><br><span class="line"><span class="keyword">else</span> plan = customer.getPlan();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="动机-6"><a href="#动机-6" class="headerlink" title="动机"></a>动机</h2><ul><li>当某个字段内容为null时，多态可扮演另一个较不直观的用途</li></ul><h1 id="8-Introduce-Assertion（引入断言）"><a href="#8-Introduce-Assertion（引入断言）" class="headerlink" title="8. Introduce Assertion（引入断言）"></a>8. Introduce Assertion（引入断言）</h1><blockquote><p>某一段代码需要对程序状态做出某种假设</p><p>以断言明确表现这种假设。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">getExpenseLimit</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (_expenseLimit != NULL_EXPENSE)?</span><br><span class="line">    _expenseLimit :</span><br><span class="line">  _primaryProject.getMemberExpenseLimit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">getExpenseLimit</span><span class="params">()</span> &#123;</span><br><span class="line">  Assert.isTrue(_expenseLimit != NULL_EXPENSE || _primaryProject != <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> (_expenseLimit != NULL_EXPENSE)?</span><br><span class="line">    _expenseLimit :</span><br><span class="line">  _primaryProject.getMemberExpenseLimit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动机-7"><a href="#动机-7" class="headerlink" title="动机"></a>动机</h2><ul><li>常常会有一段代码：只有当某个条件为真时，该段代码才能正常运行。使用断言明确标明这些假设。</li><li>断言可作为交流与调试的辅助</li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li>《重构-改善既有代码的设计》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重构列表-重新组织数据</title>
      <link href="/2023/01/25/%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E6%95%B0%E6%8D%AE/"/>
      <url>/2023/01/25/%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Self-Encapsulate-Field（自封装字段）"><a href="#1-Self-Encapsulate-Field（自封装字段）" class="headerlink" title="1. Self Encapsulate Field（自封装字段）"></a>1. Self Encapsulate Field（自封装字段）</h1><blockquote><p>为这个字段建立取值&#x2F;设值函数，并且只以这些函数来访问字段</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> _low ,_high;</span><br><span class="line">bolean <span class="title function_">includes</span> <span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg &gt;= _low &amp;&amp; arg &lt;= _high;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> _low ,_high;</span><br><span class="line">bolean <span class="title function_">includes</span> <span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg &gt;= getLow() &amp;&amp; arg &lt;= getHigh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLow</span><span class="params">()</span> &#123;<span class="keyword">return</span> _low;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getHigh</span><span class="params">()</span>&#123;<span class="keyword">return</span> _high;&#125;</span><br></pre></td></tr></table></figure><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>如果想访问超类的一个字段，却又想在子类中将对这个变量的访问改为一个计算后的值。</li></ul><h1 id="2-Replace-Data-Value-with-Object-（以对象取代数据值）"><a href="#2-Replace-Data-Value-with-Object-（以对象取代数据值）" class="headerlink" title="2. Replace Data Value with Object （以对象取代数据值）"></a>2. Replace Data Value with Object （以对象取代数据值）</h1><blockquote><p>将数据项变成对象</p></blockquote><ol><li><p><img src="/../img/replaceDataValueWithObj1.png"></p></li><li><p><img src="/../img/replaceDataValueWithObj2.png"></p></li></ol><h2 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h2><ul><li>当Duplicate Code 坏味道和Feature Envy坏味道开始出现，就应该将数据值变成对象</li></ul><h1 id="3-Change-Value-to-Reference-（将值对象改为引用对象）"><a href="#3-Change-Value-to-Reference-（将值对象改为引用对象）" class="headerlink" title="3. Change Value to Reference （将值对象改为引用对象）"></a>3. Change Value to Reference （将值对象改为引用对象）</h1><blockquote><p>将这个值对象变成引用对象</p></blockquote><ol><li><p><img src="/../img/replaceDataValueWithObj2.png"></p></li><li><p><img src="/../img/changeValuetoReference.png"></p></li></ol><h2 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h2><ul><li>对对象做一个有用的分类：引用对象和值对象。</li><li>可能会希望给这个对象加入一些可修改数据，并确保对任何一个对象的修改都能影响到所有引用此一对象的地方。这个时候就要将对象变成一个引用对象。</li></ul><h1 id="4-Change-Reference-to-Value-（将引用对象改为值对象）"><a href="#4-Change-Reference-to-Value-（将引用对象改为值对象）" class="headerlink" title="4. Change Reference to Value （将引用对象改为值对象）"></a>4. Change Reference to Value （将引用对象改为值对象）</h1><blockquote><p>将它变成一个值对象</p></blockquote><ol><li><p><img src="/../img/changeValuetoReference.png"></p></li><li><p><img src="/../img/replaceDataValueWithObj2.png"></p></li></ol><h2 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h2><ul><li>引用对象开始变得难以使用，也许就应该将它改为值对象</li><li>值对象有一个非常重要的特质：不可变</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>如果无法将该对象修改为不可变的，则放弃使用本项重构</li><li>建立equals() 和 hashCode()</li></ul><h1 id="5-Replace-Array-with-Object-（以对象取代数组）"><a href="#5-Replace-Array-with-Object-（以对象取代数组）" class="headerlink" title="5. Replace Array with Object （以对象取代数组）"></a>5. Replace Array with Object （以对象取代数组）</h1><blockquote><p>以对象替换数组。对数组中的每个元素，以一个字段来表示</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] row = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>];</span><br><span class="line">row[<span class="number">0</span>] = <span class="string">&quot;LiverPool&quot;</span>;</span><br><span class="line">row[<span class="number">1</span>] = <span class="string">&quot;15&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Performance</span> <span class="variable">row</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Performance</span>();</span><br><span class="line">row.setName(<span class="string">&quot;LiverPool&quot;</span>);</span><br><span class="line">row.setWins(<span class="string">&quot;15&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h2><ul><li>一个数组容纳来多种不同的对象，会给用户带来麻烦</li></ul><h1 id="6-Duplicate-Observed-Data-（复制“被监视数据”）"><a href="#6-Duplicate-Observed-Data-（复制“被监视数据”）" class="headerlink" title="6. Duplicate Observed Data （复制“被监视数据”）"></a>6. Duplicate Observed Data （复制“被监视数据”）</h1><blockquote><p>将该数据复制到一个领域对象中。建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据。</p></blockquote><ol><li><p><img src="/../img/duplicateObservedData1.png"></p></li><li></li></ol><p><img src="/../img/duplicateObservedData2.webp"></p><h2 id="动机-5"><a href="#动机-5" class="headerlink" title="动机"></a>动机</h2><ul><li>将处理用户界面和处理业务逻辑的代码分开</li></ul><h1 id="7-Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向关联）"><a href="#7-Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向关联）" class="headerlink" title="7. Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）"></a>7. Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）</h1><blockquote><p>添加一个反向指针，并使修改函数能够同时更新两条连接</p></blockquote><p>1. </p><p><img src="/../img/cuab1.webp"></p><ol start="2"><li><img src="/../img/cuab2.webp"></li></ol><h2 id="动机-6"><a href="#动机-6" class="headerlink" title="动机"></a>动机</h2><ul><li>引用类需要得到其引用者以便进行某些处理</li></ul><h1 id="8-Change-Bidirectional-Association-to-Unidirectional（将双向关联改为单向关联）"><a href="#8-Change-Bidirectional-Association-to-Unidirectional（将双向关联改为单向关联）" class="headerlink" title="8. Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）"></a>8. Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）</h1><blockquote><p>去除不必要的关联</p></blockquote><ol><li><img src="/../img/cuab2.webp"></li><li><img src="/../img/cuab1.webp"></li></ol><h2 id="动机-7"><a href="#动机-7" class="headerlink" title="动机"></a>动机</h2><ul><li>维护双向连接、确保对象被正确创建和删除，增加了复杂度</li><li>大量的双向连接很容易造成“僵尸对象”</li><li>双向关联迫使两个类之间有了依赖</li></ul><h1 id="9-Replace-Magic-Number-with-Symbolic-Constant-（以字面量取代魔法数）"><a href="#9-Replace-Magic-Number-with-Symbolic-Constant-（以字面量取代魔法数）" class="headerlink" title="9. Replace Magic Number with Symbolic Constant （以字面量取代魔法数）"></a>9. Replace Magic Number with Symbolic Constant （以字面量取代魔法数）</h1><blockquote><p>创造一个常量，根据其意义为它命名，并将上述的字面量值替换为这个常量</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">potentialEnergy</span><span class="params">(<span class="type">double</span> mass , <span class="type">double</span> height)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> mass * <span class="number">9.81</span> * height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">GRAVITATIONAL_CONSTANT</span> <span class="operator">=</span> <span class="number">9.18</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">potentialEnergy</span><span class="params">(<span class="type">double</span> mass , <span class="type">double</span> height)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> mass * GRAVITATIONAL_CONSTANT * height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动机-8"><a href="#动机-8" class="headerlink" title="动机"></a>动机</h2><ul><li>魔法数是指拥有特殊意义，却又不能明确表现出这种意义的数字。一旦这些数发生改变，查找修改是一场噩梦。</li><li>常量不会造成任何性能开销，却可以大大提高代码的可读性。</li></ul><h1 id="10-Encapsulate-Field-（封装字段）"><a href="#10-Encapsulate-Field-（封装字段）" class="headerlink" title="10. Encapsulate Field （封装字段）"></a>10. Encapsulate Field （封装字段）</h1><blockquote><p>将它声明为private ，并提供相应的访问函数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String _name;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String _name;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> _name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String arg)</span>&#123;</span><br><span class="line">  _name = arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动机-9"><a href="#动机-9" class="headerlink" title="动机"></a>动机</h2><ul><li>面向对象的首要原则之一就是封装，或者成为“数据隐藏”。</li><li>数据声明为public是一种不好的做法，因为这样会降低程序的模块化程度。</li></ul><h1 id="11-Encapsulate-Collection-（封装集合）"><a href="#11-Encapsulate-Collection-（封装集合）" class="headerlink" title="11. Encapsulate Collection （封装集合）"></a>11. Encapsulate Collection （封装集合）</h1><blockquote><p>让这个函数返回该集合的一个只读副本，并在这个类中提供添加&#x2F;移除集合元素的函数。</p></blockquote><ol><li><p><img src="/../img/ec1.png"></p></li><li><p><img src="/../img/ec2.png"></p></li></ol><h2 id="动机-10"><a href="#动机-10" class="headerlink" title="动机"></a>动机</h2><ul><li>取值函数不该返回集合本身，应该避免用户直接操作对象内所保存的集合，并隐藏对象内与用户无关的数据结构。</li><li>不应该为这整个集合提供一个设值函数，但应该提供集合添加&#x2F;移除元素的函数。</li></ul><h1 id="12-Replace-Record-with-Data-Class（以数据类取代记录）"><a href="#12-Replace-Record-with-Data-Class（以数据类取代记录）" class="headerlink" title="12. Replace Record with Data Class（以数据类取代记录）"></a>12. Replace Record with Data Class（以数据类取代记录）</h1><blockquote><p>为该记录创建一个“哑”数据对象。</p></blockquote><h2 id="动机-11"><a href="#动机-11" class="headerlink" title="动机"></a>动机</h2><ul><li>程序是通过一个传统API来与记录结构交流，或者处理从数据库读出的记录。这时候就需要创建一个接口类，用以处理这些外来数据。</li></ul><h1 id="13-Replace-Type-Code-with-Class-（以类取代类型码）"><a href="#13-Replace-Type-Code-with-Class-（以类取代类型码）" class="headerlink" title="13. Replace Type Code with Class （以类取代类型码）"></a>13. Replace Type Code with Class （以类取代类型码）</h1><blockquote><p>以一个新的类替换该数值类型码</p></blockquote><ol><li><p><img src="/../img/rtcc1.png"></p></li><li><p><img src="/../img/rtcc2.webp"></p></li></ol><h2 id="动机-12"><a href="#动机-12" class="headerlink" title="动机"></a>动机</h2><ul><li>任何接受类型码作为参数的函数，所期望的实际上是一个数值，无法强制使用符号名</li><li>如果将数值换成一个类，编译器就可以对这个类进行类型检验</li></ul><h1 id="14-Replace-Type-Code-with-Subclasses-（以子类取代类型码）"><a href="#14-Replace-Type-Code-with-Subclasses-（以子类取代类型码）" class="headerlink" title="14. Replace Type Code with Subclasses （以子类取代类型码）"></a>14. Replace Type Code with Subclasses （以子类取代类型码）</h1><blockquote><p>以子类取代这个类型码</p></blockquote><ol><li><p><img src="/../img/rtcs1.png"></p></li><li><p><img src="/../img/rtcs2.webp"></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Employee <span class="title function_">create</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ENGINEER :</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Engineer</span>();</span><br><span class="line">    <span class="keyword">case</span> SALESMAN:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Salesman</span>();</span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Incorrect type code value&quot;</span>);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="动机-13"><a href="#动机-13" class="headerlink" title="动机"></a>动机</h2><ul><li>如果类型码影响宿主类的行为，那么最好的办法就是借助多态来处理变化行为</li><li>一般这种情况的标志就是像switch这样的条件表达式</li></ul><h1 id="15-Replace-Type-Code-with-State-x2F-Strategy-（以State-x2F-Strategy取代类型码）"><a href="#15-Replace-Type-Code-with-State-x2F-Strategy-（以State-x2F-Strategy取代类型码）" class="headerlink" title="15. Replace Type Code with State&#x2F;Strategy （以State&#x2F;Strategy取代类型码）"></a>15. Replace Type Code with State&#x2F;Strategy （以State&#x2F;Strategy取代类型码）</h1><blockquote><p>以状态对象取代类型码</p></blockquote><ol><li><p><img src="/../img/rtcs1.png"></p></li><li><p><img src="/../img/rtcss.webp"></p></li></ol><h2 id="动机-14"><a href="#动机-14" class="headerlink" title="动机"></a>动机</h2><ul><li>如果“类型码的值在对象生命周期中发生变化” 或 “其他原因使得宿主类不能被继承”，可以使用本重构</li><li>本重构使用State模式（状态模式）或Strategy模式（策略模式）</li></ul><h1 id="16-Replace-Subclass-with-Fields-（以字段取代子类）"><a href="#16-Replace-Subclass-with-Fields-（以字段取代子类）" class="headerlink" title="16. Replace Subclass with Fields （以字段取代子类）"></a>16. Replace Subclass with Fields （以字段取代子类）</h1><blockquote><p>修改这些函数，使它们返回超类中的某个（新增）字段，然后销毁子类</p></blockquote><ol><li><p><img src="/../img/rsf1.webp"></p></li><li></li></ol><p><img src="/../img/rsf2.png"></p><h2 id="动机-15"><a href="#动机-15" class="headerlink" title="动机"></a>动机</h2><ul><li>建立子类的目的是为了增加新特性或变化其行为。有一种变化行为成为“常量函数”，会返回一个硬编码的值。</li><li>若子类中只有常量函数，实在没有足够的存在价值。可以去除这样的子类，避免因继承而带来的额外复杂性。</li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li>《重构-改善既有代码的设计》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重构列表-在对象之间搬移特性</title>
      <link href="/2023/01/23/%E5%9C%A8%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E6%90%AC%E7%A7%BB%E7%89%B9%E6%80%A7/"/>
      <url>/2023/01/23/%E5%9C%A8%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E6%90%AC%E7%A7%BB%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在对象的设计过程中，“决定把责任放在哪儿” 即使不是最重要的事，也是最重要的事之一。</p></blockquote><h1 id="1-Move-Method（搬移函数）"><a href="#1-Move-Method（搬移函数）" class="headerlink" title="1. Move Method（搬移函数）"></a>1. Move Method（搬移函数）</h1><blockquote><p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是将旧函数完全移除。</p></blockquote><p><img src="/../img/moveMethod1.png"></p><p><img src="/../img/moveMethod2.png"></p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>如果一个类有太多行为，或如果一个类与另一个类有太多合作而形成高度耦合，就搬移函数。</li><li>使用另一个对象的次数比使用自己所驻对象的次数还多。</li></ul><h1 id="2-Move-Field（搬移字段）"><a href="#2-Move-Field（搬移字段）" class="headerlink" title="2. Move Field（搬移字段）"></a>2. Move Field（搬移字段）</h1><blockquote><p>在目标类新建一个字段，修改源字段的所有用户，令它们改用新字段。</p></blockquote><p><img src="/../img/moveField1.png"></p><p><img src="/../img/moveField2.png"></p><h2 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h2><ul><li>对于一个字段，在其所驻类之外的另一个类中有更多函数使用了它，就会考虑搬移这个字段。</li></ul><h1 id="3-Extract-Class（提炼类）"><a href="#3-Extract-Class（提炼类）" class="headerlink" title="3. Extract Class（提炼类）"></a>3. Extract Class（提炼类）</h1><blockquote><p>建立一个新类，将相关的字段和函数从旧类搬移到新类。</p></blockquote><p><img src="/../img/extractClass1.png"></p><p><img src="/../img/extractClass2.png"></p><h2 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h2><ul><li>一个类应该是一个清楚的抽象，处理一些明确的责任</li><li>类含有大量函数和数据</li><li>开发后期出现的信号是类的子类化方式</li></ul><h1 id="4-Inline-Class-（将类内联化）"><a href="#4-Inline-Class-（将类内联化）" class="headerlink" title="4. Inline Class （将类内联化）"></a>4. Inline Class （将类内联化）</h1><blockquote><p>将这个类的所有特性搬移到另一个类中，然后移除原类</p></blockquote><ol><li></li></ol><p><img src="/../img/extractClass2.png"></p><ol start="2"><li></li></ol><p><img src="/../img/extractClass1.png"></p><h2 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h2><ul><li>如果一个类不再承担足够责任、不再有单独存在的理由</li></ul><h1 id="5-Hide-Delegate-（隐藏“委托关系”）"><a href="#5-Hide-Delegate-（隐藏“委托关系”）" class="headerlink" title="5. Hide Delegate （隐藏“委托关系”）"></a>5. Hide Delegate （隐藏“委托关系”）</h1><blockquote><p>在服务类上建立客户所需的所有函数，用以隐藏委托关系</p></blockquote><ol><li></li></ol><p><img src="/../img/hideDelegate1.png"></p><ol start="2"><li><img src="/../img/hideDelegate2.png"></li></ol><h2 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h2><ul><li>“封装”意味着每个对象都应该尽可能少了解系统的其他部分。</li><li>万一委托关系发生变化，客户也得相应变化。将委托关系隐藏起来，从而去除这种依赖。</li></ul><h1 id="6-Remove-Middle-Man-（移除中间人）"><a href="#6-Remove-Middle-Man-（移除中间人）" class="headerlink" title="6. Remove Middle Man （移除中间人）"></a>6. Remove Middle Man （移除中间人）</h1><blockquote><p>让客户直接调用受委托类</p></blockquote><ol><li><p><img src="/../img/hideDelegate2.png"></p></li><li><p><img src="/../img/hideDelegate1.png"></p></li></ol><h2 id="动机-5"><a href="#动机-5" class="headerlink" title="动机"></a>动机</h2><ul><li>“封装受委托对象”要付出代价： 每当客户要使用委托类的新特性时，你就必须在服务端添加一个简单的委托函数。随着受委托的特性越来越多，服务类完全变成了一个“中间人”。</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>也可能想保留一部分委托关系。希望对某些客户隐藏委托关系，对另一些用户直接使用委托关系。</li></ul><h1 id="7-Introduce-Foreign-Method（引入外加函数）"><a href="#7-Introduce-Foreign-Method（引入外加函数）" class="headerlink" title="7. Introduce Foreign Method（引入外加函数）"></a>7. Introduce Foreign Method（引入外加函数）</h1><blockquote><p>在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">newStart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(previousEnd.getYear(),previousEnd.getMonth(),previousEnd.getDate()+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">newStart</span> <span class="operator">=</span> nextDate(previousEnd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Date <span class="title function_">nextDate</span><span class="params">(Date arg)</span> &#123;</span><br><span class="line">  <span class="comment">// foreign method, should be on date</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(arg.getYear(),arg.getMonth(),arg.getDate()+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="动机-6"><a href="#动机-6" class="headerlink" title="动机"></a>动机</h2><ul><li>需要一项新的服务，这个类无法供应</li><li>明确信号：这个函数原本应该在提供服务的类中实现</li></ul><h1 id="8-Introduce-Local-Extension-（引入本地扩展）"><a href="#8-Introduce-Local-Extension-（引入本地扩展）" class="headerlink" title="8. Introduce Local Extension （引入本地扩展）"></a>8. Introduce Local Extension （引入本地扩展）</h1><blockquote><p>建立一个新类，使它包含这些额外函数。让其成为源类的子类或者包装类</p></blockquote><ol><li><img src="/../img/introduceLocalExtension1.png"></li><li><img src="/../img/introduceLocalExtension2.png"></li></ol><h2 id="动机-7"><a href="#动机-7" class="headerlink" title="动机"></a>动机</h2><ul><li>需要的额外函数超过两个，外加函数很难控制。需要将这些函数组织在一起，放到恰当的地方</li><li>要达到这一目的，两种标准对象技术—— 子类化（subclassing）和包装（wrapping）——统称本地扩展（local extension)</li></ul><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><ul><li>一般来说，不在扩展类中重写原始类的函数，只会添加新函数</li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li>《重构-改善既有代码的设计》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重构列表-重新组织函数</title>
      <link href="/2023/01/20/%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E5%87%BD%E6%95%B0/"/>
      <url>/2023/01/20/%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>几乎所有时刻，问题都源于Long Method(过长函数)</p></blockquote><h1 id="1-Extract-Method-提炼函数"><a href="#1-Extract-Method-提炼函数" class="headerlink" title="1. Extract Method(提炼函数)"></a>1. Extract Method(提炼函数)</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printOwing</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">printBanner();</span><br><span class="line"></span><br><span class="line"><span class="comment">//print details</span></span><br><span class="line">System.out.println(<span class="string">&quot;....&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;....&quot;</span> + amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将“&#x2F;&#x2F;print details”这段代码放到独立函数当中，并让函数名解释用途。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printOwing</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">printBanner();</span><br><span class="line"><span class="comment">//print details</span></span><br><span class="line">printDetails(amount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printDetails</span><span class="params">(<span class="type">double</span> amount)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;....&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;....&quot;</span> + amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>简短且命名良好的函数：</p><ul><li>颗粒度小，被复用的机会就更大</li><li>使高层函数读起来像一系列注释</li><li>覆写更容易</li></ul><h1 id="2-Inline-Method（内联函数）"><a href="#2-Inline-Method（内联函数）" class="headerlink" title="2. Inline Method（内联函数）"></a>2. Inline Method（内联函数）</h1><blockquote><p>在函数调用点插入函数本体，然后移除该函数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getRating</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (moreThanFiveLateDeliveries()) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">moreThanFiveLateDeliveries</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> _numberOfLateDeliveries &gt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getRating</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> _numberOfLateDeliveries &gt; <span class="number">5</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h2><ul><li>非必要的间接性让人不舒服</li><li>如果有一群不合理的函数，可以先将它们内联到一个大型函数当中，再从中提炼出合理的小函数。</li><li>使用了太多间接层。找出有用的间接层，将无用的间接层去除。</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>如果具备多态特性，子类重写了该函数，不要将函数进行内联</li></ul><h1 id="3-Inline-Temp（内联临时变量）"><a href="#3-Inline-Temp（内联临时变量）" class="headerlink" title="3. Inline Temp（内联临时变量）"></a>3. Inline Temp（内联临时变量）</h1><blockquote><p>将所有对该变量的引用动作，替换为对它赋值的那个表达式自身。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">basePrice</span> <span class="operator">=</span> anOrder.basePrice();</span><br><span class="line"><span class="keyword">return</span> (basePrice &gt; <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> anOrder.basePrice() &gt; <span class="number">1000</span></span><br></pre></td></tr></table></figure><h2 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h2><ul><li>某个临时变量被赋予某个函数的返回值</li></ul><h1 id="4-Replace-Temp-with-Query（以查询取代临时变量）"><a href="#4-Replace-Temp-with-Query（以查询取代临时变量）" class="headerlink" title="4. Replace Temp with Query（以查询取代临时变量）"></a>4. Replace Temp with Query（以查询取代临时变量）</h1><blockquote><p>将这个临时变量的引用点替换为对新函数的调用。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">basePrice</span> <span class="operator">=</span> _quantity * _itemPrice;</span><br><span class="line"><span class="keyword">if</span> (basePrice &gt; <span class="number">1000</span>)</span><br><span class="line"><span class="keyword">return</span> basePrice * <span class="number">0.95</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> basePrice * <span class="number">0.98</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (basePrice() &gt; <span class="number">1000</span>)</span><br><span class="line"><span class="keyword">return</span> basePrice() * <span class="number">0.95</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> basePrice() * <span class="number">0.98</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">basePrice</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> _quantity * _itemPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h2><ul><li>临时变量替换为一个查询，那么同一个类中的所有函数都将可以获得这个信息。</li></ul><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><ul><li>找出只被赋值一次的临时变量</li></ul><h1 id="5-Introduce-Explaining-Variable（引入解释性变量）"><a href="#5-Introduce-Explaining-Variable（引入解释性变量）" class="headerlink" title="5. Introduce Explaining Variable（引入解释性变量）"></a>5. Introduce Explaining Variable（引入解释性变量）</h1><blockquote><p>将该复杂表达式的结构放进一个临时变量</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (platform.toUpperCase().indexOf(<span class="string">&quot;MAC&quot;</span>) &gt; -<span class="number">1</span> &amp;&amp;</span><br><span class="line">browser.toUpperCase().indexOf(<span class="string">&quot;IE&quot;</span>) &gt; -<span class="number">1</span> &amp;&amp;</span><br><span class="line">wasInitialized() &amp;&amp; resize &gt; <span class="number">0</span> )&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">isMacOs</span> <span class="operator">=</span> platform.toUpperCase().indexOf(<span class="string">&quot;MAC&quot;</span>) &gt; -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">isIEBrowser</span> <span class="operator">=</span> browser.toUpperCase().indexOf(<span class="string">&quot;IE&quot;</span>) &gt; -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">wasResized</span> <span class="operator">=</span> resize &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isMacOs &amp;&amp; isIEBrower &amp;&amp; wasInitialized() &amp;&amp; wasResized)&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h2><ul><li>表达式有可能非常复杂而难以阅读。临时变量可以帮助你将表达式分解</li><li>在较长算法中，可以运用临时变量来解释每一步运算的意义</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>在Extract Method 需要花费更大工作量的时候使用</li></ul><h1 id="6-Split-Temporary-Variable（分解临时变量）"><a href="#6-Split-Temporary-Variable（分解临时变量）" class="headerlink" title="6. Split Temporary Variable（分解临时变量）"></a>6. Split Temporary Variable（分解临时变量）</h1><blockquote><p>针对每次赋值，创造一个独立、对应的临时变量。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">2</span> * (_height + _width);</span><br><span class="line">System.out.println(temp);</span><br><span class="line">temp = _height * _width;</span><br><span class="line">System.out.println(temp);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">double</span> <span class="variable">perimeter</span> <span class="operator">=</span> <span class="number">2</span> * (_height + _width);</span><br><span class="line">System.out.println(perimeter);</span><br><span class="line"><span class="keyword">final</span> <span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> _height * _width;</span><br><span class="line">System.out.println(area);</span><br></pre></td></tr></table></figure><h2 id="动机-5"><a href="#动机-5" class="headerlink" title="动机"></a>动机</h2><ul><li>临时变量应该只被赋值一次。如果超过一次，就意味着它们在函数中承担了一个以上的责任。</li></ul><h1 id="7-Remove-Assignments-to-Parameters（移除对参数的赋值）"><a href="#7-Remove-Assignments-to-Parameters（移除对参数的赋值）" class="headerlink" title="7. Remove Assignments to Parameters（移除对参数的赋值）"></a>7. Remove Assignments to Parameters（移除对参数的赋值）</h1><blockquote><p>以一个临时变量取代该参数的位置</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">discount</span> <span class="params">(<span class="type">int</span> inputVal, <span class="type">int</span> quantity , <span class="type">int</span> yearToDate)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (inputVal &gt; <span class="number">50</span> ) input -= <span class="number">2</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">discount</span><span class="params">(<span class="type">int</span> inputVal,<span class="type">int</span> quantity,<span class="type">int</span> yearToDate)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> inputVal;</span><br><span class="line"><span class="keyword">if</span> (inputVal &gt; <span class="number">50</span> ) result -= <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h2 id="动机-6"><a href="#动机-6" class="headerlink" title="动机"></a>动机</h2><ul><li>这样的做法，降低了代码的清晰度，而且混用了按值传递和按引用传递这两种参数传递方式</li></ul><h1 id="8-Replace-Method-with-Method-Object-（以函数对象取代函数）"><a href="#8-Replace-Method-with-Method-Object-（以函数对象取代函数）" class="headerlink" title="8. Replace Method with Method Object （以函数对象取代函数）"></a>8. Replace Method with Method Object （以函数对象取代函数）</h1><blockquote><p>将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line"><span class="type">double</span> <span class="title function_">price</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">double</span> primaryBasePrice;</span><br><span class="line"><span class="type">double</span> secondaryBasePrice;</span><br><span class="line"><span class="type">double</span> tertiaryBasePrice;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/../img/replaceMethodWithMethodObj.png" alt="replaceMethodWithMethodObj"></h2><h2 id="动机-7"><a href="#动机-7" class="headerlink" title="动机"></a>动机</h2><ul><li>局部变量的存在会增加函数分解难度</li><li>无法用Replace Temp with Query 拆解一个需要拆解的函数</li></ul><h1 id="9-Substitute-Algorithm-（替换算法）"><a href="#9-Substitute-Algorithm-（替换算法）" class="headerlink" title="9. Substitute Algorithm （替换算法）"></a>9. Substitute Algorithm （替换算法）</h1><blockquote><p>将函数本体替换为另一个算法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">foundPerson</span><span class="params">(String[] people)</span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i &lt;people.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (people[<span class="number">0</span>].equals(<span class="string">&quot;Don&quot;</span>))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Don&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">foundPerson</span><span class="params">(String[] people)</span>&#123;</span><br><span class="line"><span class="type">List</span> <span class="variable">candidates</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Don&quot;</span>,<span class="string">&quot;John&quot;</span>&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i &lt;people.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (candidates.contains(people[i]))&#123;</span><br><span class="line"><span class="keyword">return</span> people[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动机-8"><a href="#动机-8" class="headerlink" title="动机"></a>动机</h2><ul><li>在原先的做法之外，有更简单的解决方案。</li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li>《重构-改善既有代码的设计》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步-自旋锁</title>
      <link href="/2022/11/24/%E5%90%8C%E6%AD%A5-%E8%87%AA%E6%97%8B%E9%94%81/"/>
      <url>/2022/11/24/%E5%90%8C%E6%AD%A5-%E8%87%AA%E6%97%8B%E9%94%81/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> 同步 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
