<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>重新组织函数</title>
      <link href="/2023/01/20/%E9%87%8D%E6%9E%84%E5%88%97%E8%A1%A8%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/01/20/%E9%87%8D%E6%9E%84%E5%88%97%E8%A1%A8%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>几乎所有时刻，问题都源于Long Method(过长函数)</p></blockquote><h1 id="Extract-Method-提炼函数"><a href="#Extract-Method-提炼函数" class="headerlink" title="Extract Method(提炼函数)"></a>Extract Method(提炼函数)</h1><pre><code class="java">void printOwing(double amount) &#123;        printBanner();                //print details        System.out.println(&quot;....&quot;);        System.out.println(&quot;....&quot; + amount);&#125;</code></pre><p>将“&#x2F;&#x2F;print details”这段代码放到独立函数当中，并让函数名解释用途。</p><pre><code class="java">void printOwing(double amount) &#123;        printBanner();        //print details        printDetails(amount);&#125;void printDetails(double amount)&#123;        System.out.println(&quot;....&quot;);        System.out.println(&quot;....&quot; + amount);&#125;</code></pre><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>简短且命名良好的函数：</p><ul><li>颗粒度小，被复用的机会就更大</li><li>使高层函数读起来像一系列注释</li><li>覆写更容易</li></ul><h1 id="Inline-Method（内联函数）"><a href="#Inline-Method（内联函数）" class="headerlink" title="Inline Method（内联函数）"></a>Inline Method（内联函数）</h1><blockquote><p>在函数调用点插入函数本体，然后移除该函数</p></blockquote><pre><code class="java">int getRating() &#123;    return (moreThanFiveLateDeliveries()) ? 2 : 1;&#125;boolean moreThanFiveLateDeliveries()&#123;    return _numberOfLateDeliveries &gt; 5;&#125;</code></pre><pre><code class="java">int getRating() &#123;    return _numberOfLateDeliveries &gt; 5 ? 2 : 1;&#125;</code></pre><h2 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h2><ul><li>非必要的间接性让人不舒服</li><li>如果有一群不合理的函数，可以先将它们内联到一个大型函数当中，再从中提炼出合理的小函数。</li><li>使用了太多间接层。找出有用的间接层，将无用的间接层去除。</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>如果具备多态特性，子类重写了该函数，不要将函数进行内联</li></ul><h1 id="Inline-Temp（内联临时变量）"><a href="#Inline-Temp（内联临时变量）" class="headerlink" title="Inline Temp（内联临时变量）"></a>Inline Temp（内联临时变量）</h1><blockquote><p>将所有对该变量的引用动作，替换为对它赋值的那个表达式自身。</p></blockquote><pre><code class="java">double basePrice = anOrder.basePrice();return (basePrice &gt; 1000)</code></pre><pre><code class="java">return anOrder.basePrice() &gt; 1000</code></pre><h2 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h2><ul><li>某个临时变量被赋予某个函数的返回值</li></ul><h1 id="Replace-Temp-with-Query（以查询取代临时变量）"><a href="#Replace-Temp-with-Query（以查询取代临时变量）" class="headerlink" title="Replace Temp with Query（以查询取代临时变量）"></a>Replace Temp with Query（以查询取代临时变量）</h1><blockquote><p>将这个临时变量的引用点替换为对新函数的调用。</p></blockquote><pre><code class="java">double basePrice = _quantity * _itemPrice;if (basePrice &gt; 1000)    return basePrice * 0.95;else     return basePrice * 0.98;</code></pre><pre><code class="java">if (basePrice() &gt; 1000)    return basePrice() * 0.95;else     return basePrice() * 0.98;double basePrice()&#123;    return _quantity * _itemPrice;&#125;</code></pre><h2 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h2><ul><li>临时变量替换为一个查询，那么同一个类中的所有函数都将可以获得这个信息。</li></ul><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><ul><li>找出只被赋值一次的临时变量</li></ul><h1 id="Introduce-Explaining-Variable（引入解释性变量）"><a href="#Introduce-Explaining-Variable（引入解释性变量）" class="headerlink" title="Introduce Explaining Variable（引入解释性变量）"></a>Introduce Explaining Variable（引入解释性变量）</h1><blockquote><p>将该复杂表达式的结构放进一个临时变量</p></blockquote><pre><code class="java">if (platform.toUpperCase().indexOf(&quot;MAC&quot;) &gt; -1 &amp;&amp;    browser.toUpperCase().indexOf(&quot;IE&quot;) &gt; -1 &amp;&amp;    wasInitialized() &amp;&amp; resize &gt; 0 )&#123;&#125;</code></pre><pre><code class="java">final boolean isMacOs = platform.toUpperCase().indexOf(&quot;MAC&quot;) &gt; -1;final boolean isIEBrowser = browser.toUpperCase().indexOf(&quot;IE&quot;) &gt; -1;final boolean wasResized = resize &gt; 0;if (isMacOs &amp;&amp; isIEBrower &amp;&amp; wasInitialized() &amp;&amp; wasResized)&#123;&#125;</code></pre><h2 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h2><ul><li>表达式有可能非常复杂而难以阅读。临时变量可以帮助你将表达式分解</li><li>在较长算法中，可以运用临时变量来解释每一步运算的意义</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>在Extract Method 需要花费更大工作量的时候使用</li></ul><h1 id="Split-Temporary-Variable（分解临时变量）"><a href="#Split-Temporary-Variable（分解临时变量）" class="headerlink" title="Split Temporary Variable（分解临时变量）"></a>Split Temporary Variable（分解临时变量）</h1><blockquote><p>针对每次赋值，创造一个独立、对应的临时变量。</p></blockquote><pre><code class="java">double temp = 2 * (_height + _width);System.out.println(temp);temp = _height * _width;System.out.println(temp);</code></pre><pre><code class="java">final double perimeter = 2 * (_height + _width);System.out.println(perimeter);final double area = _height * _width;System.out.println(area);</code></pre><h2 id="动机-5"><a href="#动机-5" class="headerlink" title="动机"></a>动机</h2><ul><li>临时变量应该只被赋值一次。如果超过一次，就意味着它们在函数中承担了一个以上的责任。</li></ul><h1 id="Remove-Assignments-to-Parameters（移除对参数的赋值）"><a href="#Remove-Assignments-to-Parameters（移除对参数的赋值）" class="headerlink" title="Remove Assignments to Parameters（移除对参数的赋值）"></a>Remove Assignments to Parameters（移除对参数的赋值）</h1><blockquote><p>以一个临时变量取代该参数的位置</p></blockquote><pre><code class="java">int discount (int inputVal, int quantity , int yearToDate) &#123;    if (inputVal &gt; 50 ) input -= 2;</code></pre><pre><code class="java">int discount(int inputVal,int quantity,int yearToDate) &#123;    int result = inputVal;    if (inputVal &gt; 50 ) result -= 2;</code></pre><h2 id="动机-6"><a href="#动机-6" class="headerlink" title="动机"></a>动机</h2><ul><li>这样的做法，降低了代码的清晰度，而且混用了按值传递和按引用传递这两种参数传递方式</li></ul><h1 id="Replace-Method-with-Method-Object-（以函数对象取代函数）"><a href="#Replace-Method-with-Method-Object-（以函数对象取代函数）" class="headerlink" title="Replace Method with Method Object （以函数对象取代函数）"></a>Replace Method with Method Object （以函数对象取代函数）</h1><blockquote><p>将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段</p></blockquote><pre><code class="java">class Order &#123;    double price() &#123;        double primaryBasePrice;        double secondaryBasePrice;        double tertiaryBasePrice;    &#125;&#125;</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/../img/replaceMethodWithMethodObj.png" alt="replaceMethodWithMethodObj"></h2><h2 id="动机-7"><a href="#动机-7" class="headerlink" title="动机"></a>动机</h2><ul><li>局部变量的存在会增加函数分解难度</li><li>无法用Replace Temp with Query 拆解一个需要拆解的函数</li></ul><h1 id="Substitute-Algorithm-（替换算法）"><a href="#Substitute-Algorithm-（替换算法）" class="headerlink" title="Substitute Algorithm （替换算法）"></a>Substitute Algorithm （替换算法）</h1><blockquote><p>将函数本体替换为另一个算法</p></blockquote><pre><code class="java">String foundPerson(String[] people)&#123;    for (int i =0; i &lt;people.length;i++)&#123;        if (people[0].equals(&quot;Don&quot;))&#123;            return &quot;Don&quot;;        &#125;    &#125;    return &quot;&quot;;&#125;</code></pre><pre><code class="java">String foundPerson(String[] people)&#123;    List candidates = Arrays.asList(new String[]&#123;&quot;Don&quot;,&quot;John&quot;&#125;);    for (int i =0; i &lt;people.length;i++)&#123;        if (candidates.contains(people[i]))&#123;            return people[i];        &#125;    &#125;    return &quot;&quot;;&#125;</code></pre><h2 id="动机-8"><a href="#动机-8" class="headerlink" title="动机"></a>动机</h2><ul><li>在原先的做法之外，有更简单的解决方案。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步-自旋锁</title>
      <link href="/2022/11/24/%E5%90%8C%E6%AD%A5-%E8%87%AA%E6%97%8B%E9%94%81/"/>
      <url>/2022/11/24/%E5%90%8C%E6%AD%A5-%E8%87%AA%E6%97%8B%E9%94%81/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> 同步 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
