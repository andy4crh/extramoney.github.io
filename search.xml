<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>在对象之间搬移特性</title>
      <link href="/2023/01/23/%E5%9C%A8%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E6%90%AC%E7%A7%BB%E7%89%B9%E6%80%A7/"/>
      <url>/2023/01/23/%E5%9C%A8%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E6%90%AC%E7%A7%BB%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在对象的设计过程中，“决定把责任放在哪儿” 即使不是最重要的事，也是最重要的事之一。</p></blockquote><h1 id="Move-Method（搬移函数）"><a href="#Move-Method（搬移函数）" class="headerlink" title="Move Method（搬移函数）"></a>Move Method（搬移函数）</h1><blockquote><p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是将旧函数完全移除。</p></blockquote><p><img src="/../img/moveMethod1.png"></p><p><img src="/../img/moveMethod2.png"></p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>如果一个类有太多行为，或如果一个类与另一个类有太多合作而形成高度耦合，就搬移函数。</li><li>使用另一个对象的次数比使用自己所驻对象的次数还多。</li></ul><h1 id="Move-Field（搬移字段）"><a href="#Move-Field（搬移字段）" class="headerlink" title="Move Field（搬移字段）"></a>Move Field（搬移字段）</h1><blockquote><p>在目标类新建一个字段，修改源字段的所有用户，令它们改用新字段。</p></blockquote><p><img src="/../img/moveField1.png"></p><p><img src="/../img/moveField2.png"></p><h2 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h2><ul><li>对于一个字段，在其所驻类之外的另一个类中有更多函数使用了它，就会考虑搬移这个字段。</li></ul><h1 id="Extract-Class（提炼类）"><a href="#Extract-Class（提炼类）" class="headerlink" title="Extract Class（提炼类）"></a>Extract Class（提炼类）</h1><blockquote><p>建立一个新类，将相关的字段和函数从旧类搬移到新类。</p></blockquote><p><img src="/../img/extractClass1.png"></p><p><img src="/../img/extractClass2.png"></p><h2 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h2><ul><li>一个类应该是一个清楚的抽象，处理一些明确的责任</li><li>类含有大量函数和数据</li><li>开发后期出现的信号是类的子类化方式</li></ul><h1 id="Inline-Class-（将类内联化）"><a href="#Inline-Class-（将类内联化）" class="headerlink" title="Inline Class （将类内联化）"></a>Inline Class （将类内联化）</h1><blockquote><p>将这个类的所有特性搬移到另一个类中，然后移除原类</p></blockquote><ol><li></li></ol><p><img src="/../img/extractClass2.png"></p><ol start="2"><li></li></ol><p><img src="/../img/extractClass1.png"></p><h2 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h2><ul><li>如果一个类不再承担足够责任、不再有单独存在的理由</li></ul><h1 id="Hide-Delegate-（隐藏“委托关系”）"><a href="#Hide-Delegate-（隐藏“委托关系”）" class="headerlink" title="Hide Delegate （隐藏“委托关系”）"></a>Hide Delegate （隐藏“委托关系”）</h1><blockquote><p>在服务类上建立客户所需的所有函数，用以隐藏委托关系</p></blockquote><ol><li></li></ol><p><img src="/../img/hideDelegate1.png"></p><ol start="2"><li><img src="/../img/hideDelegate2.png"></li></ol><h2 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h2><ul><li>“封装”意味着每个对象都应该尽可能少了解系统的其他部分。</li><li>万一委托关系发生变化，客户也得相应变化。将委托关系隐藏起来，从而去除这种依赖。</li></ul><h1 id="Remove-Middle-Man-（移除中间人）"><a href="#Remove-Middle-Man-（移除中间人）" class="headerlink" title="Remove Middle Man （移除中间人）"></a>Remove Middle Man （移除中间人）</h1><blockquote><p>让客户直接调用受委托类</p></blockquote><ol><li><p><img src="/../img/hideDelegate2.png"></p></li><li><p><img src="/../img/hideDelegate1.png"></p></li></ol><h2 id="动机-5"><a href="#动机-5" class="headerlink" title="动机"></a>动机</h2><ul><li>“封装受委托对象”要付出代价： 每当客户要使用委托类的新特性时，你就必须在服务端添加一个简单的委托函数。随着受委托的特性越来越多，服务类完全变成了一个“中间人”。</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>也可能想保留一部分委托关系。希望对某些客户隐藏委托关系，对另一些用户直接使用委托关系。</li></ul><h1 id="Introduce-Foreign-Method（引入外加函数）"><a href="#Introduce-Foreign-Method（引入外加函数）" class="headerlink" title="Introduce Foreign Method（引入外加函数）"></a>Introduce Foreign Method（引入外加函数）</h1><blockquote><p>在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。</p></blockquote><pre><code class="java">Date newStart = new Date(previousEnd.getYear(),previousEnd.getMonth(),previousEnd.getDate()+1);</code></pre><pre><code class="java">Date newStart = nextDate(previousEnd);private static Date nextDate(Date arg) &#123;  // foreign method, should be on date  return new Date(arg.getYear(),arg.getMonth(),arg.getDate()+1);&#125;</code></pre><h2 id="动机-6"><a href="#动机-6" class="headerlink" title="动机"></a>动机</h2><ul><li>需要一项新的服务，这个类无法供应</li><li>明确信号：这个函数原本应该在提供服务的类中实现</li></ul><h1 id="Introduce-Local-Extension-（引入本地扩展）"><a href="#Introduce-Local-Extension-（引入本地扩展）" class="headerlink" title="Introduce Local Extension （引入本地扩展）"></a>Introduce Local Extension （引入本地扩展）</h1><blockquote><p>建立一个新类，使它包含这些额外函数。让其成为源类的子类或者包装类</p></blockquote><ol><li><img src="/../img/introduceLocalExtension1.png"></li><li><img src="/../img/introduceLocalExtension2.png"></li></ol><h2 id="动机-7"><a href="#动机-7" class="headerlink" title="动机"></a>动机</h2><ul><li>需要的额外函数超过两个，外加函数很难控制。需要将这些函数组织在一起，放到恰当的地方</li><li>要达到这一目的，两种标准对象技术—— 子类化（subclassing）和包装（wrapping）——统称本地扩展（local extension)</li></ul><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><ul><li>一般来说，不在扩展类中重写原始类的函数，只会添加新函数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重新组织函数</title>
      <link href="/2023/01/20/%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E5%87%BD%E6%95%B0/"/>
      <url>/2023/01/20/%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>几乎所有时刻，问题都源于Long Method(过长函数)</p></blockquote><h1 id="Extract-Method-提炼函数"><a href="#Extract-Method-提炼函数" class="headerlink" title="Extract Method(提炼函数)"></a>Extract Method(提炼函数)</h1><pre><code class="java">void printOwing(double amount) &#123;        printBanner();                //print details        System.out.println(&quot;....&quot;);        System.out.println(&quot;....&quot; + amount);&#125;</code></pre><p>将“&#x2F;&#x2F;print details”这段代码放到独立函数当中，并让函数名解释用途。</p><pre><code class="java">void printOwing(double amount) &#123;        printBanner();        //print details        printDetails(amount);&#125;void printDetails(double amount)&#123;        System.out.println(&quot;....&quot;);        System.out.println(&quot;....&quot; + amount);&#125;</code></pre><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>简短且命名良好的函数：</p><ul><li>颗粒度小，被复用的机会就更大</li><li>使高层函数读起来像一系列注释</li><li>覆写更容易</li></ul><h1 id="Inline-Method（内联函数）"><a href="#Inline-Method（内联函数）" class="headerlink" title="Inline Method（内联函数）"></a>Inline Method（内联函数）</h1><blockquote><p>在函数调用点插入函数本体，然后移除该函数</p></blockquote><pre><code class="java">int getRating() &#123;    return (moreThanFiveLateDeliveries()) ? 2 : 1;&#125;boolean moreThanFiveLateDeliveries()&#123;    return _numberOfLateDeliveries &gt; 5;&#125;</code></pre><pre><code class="java">int getRating() &#123;    return _numberOfLateDeliveries &gt; 5 ? 2 : 1;&#125;</code></pre><h2 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h2><ul><li>非必要的间接性让人不舒服</li><li>如果有一群不合理的函数，可以先将它们内联到一个大型函数当中，再从中提炼出合理的小函数。</li><li>使用了太多间接层。找出有用的间接层，将无用的间接层去除。</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>如果具备多态特性，子类重写了该函数，不要将函数进行内联</li></ul><h1 id="Inline-Temp（内联临时变量）"><a href="#Inline-Temp（内联临时变量）" class="headerlink" title="Inline Temp（内联临时变量）"></a>Inline Temp（内联临时变量）</h1><blockquote><p>将所有对该变量的引用动作，替换为对它赋值的那个表达式自身。</p></blockquote><pre><code class="java">double basePrice = anOrder.basePrice();return (basePrice &gt; 1000)</code></pre><pre><code class="java">return anOrder.basePrice() &gt; 1000</code></pre><h2 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h2><ul><li>某个临时变量被赋予某个函数的返回值</li></ul><h1 id="Replace-Temp-with-Query（以查询取代临时变量）"><a href="#Replace-Temp-with-Query（以查询取代临时变量）" class="headerlink" title="Replace Temp with Query（以查询取代临时变量）"></a>Replace Temp with Query（以查询取代临时变量）</h1><blockquote><p>将这个临时变量的引用点替换为对新函数的调用。</p></blockquote><pre><code class="java">double basePrice = _quantity * _itemPrice;if (basePrice &gt; 1000)    return basePrice * 0.95;else     return basePrice * 0.98;</code></pre><pre><code class="java">if (basePrice() &gt; 1000)    return basePrice() * 0.95;else     return basePrice() * 0.98;double basePrice()&#123;    return _quantity * _itemPrice;&#125;</code></pre><h2 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h2><ul><li>临时变量替换为一个查询，那么同一个类中的所有函数都将可以获得这个信息。</li></ul><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><ul><li>找出只被赋值一次的临时变量</li></ul><h1 id="Introduce-Explaining-Variable（引入解释性变量）"><a href="#Introduce-Explaining-Variable（引入解释性变量）" class="headerlink" title="Introduce Explaining Variable（引入解释性变量）"></a>Introduce Explaining Variable（引入解释性变量）</h1><blockquote><p>将该复杂表达式的结构放进一个临时变量</p></blockquote><pre><code class="java">if (platform.toUpperCase().indexOf(&quot;MAC&quot;) &gt; -1 &amp;&amp;    browser.toUpperCase().indexOf(&quot;IE&quot;) &gt; -1 &amp;&amp;    wasInitialized() &amp;&amp; resize &gt; 0 )&#123;&#125;</code></pre><pre><code class="java">final boolean isMacOs = platform.toUpperCase().indexOf(&quot;MAC&quot;) &gt; -1;final boolean isIEBrowser = browser.toUpperCase().indexOf(&quot;IE&quot;) &gt; -1;final boolean wasResized = resize &gt; 0;if (isMacOs &amp;&amp; isIEBrower &amp;&amp; wasInitialized() &amp;&amp; wasResized)&#123;&#125;</code></pre><h2 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h2><ul><li>表达式有可能非常复杂而难以阅读。临时变量可以帮助你将表达式分解</li><li>在较长算法中，可以运用临时变量来解释每一步运算的意义</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>在Extract Method 需要花费更大工作量的时候使用</li></ul><h1 id="Split-Temporary-Variable（分解临时变量）"><a href="#Split-Temporary-Variable（分解临时变量）" class="headerlink" title="Split Temporary Variable（分解临时变量）"></a>Split Temporary Variable（分解临时变量）</h1><blockquote><p>针对每次赋值，创造一个独立、对应的临时变量。</p></blockquote><pre><code class="java">double temp = 2 * (_height + _width);System.out.println(temp);temp = _height * _width;System.out.println(temp);</code></pre><pre><code class="java">final double perimeter = 2 * (_height + _width);System.out.println(perimeter);final double area = _height * _width;System.out.println(area);</code></pre><h2 id="动机-5"><a href="#动机-5" class="headerlink" title="动机"></a>动机</h2><ul><li>临时变量应该只被赋值一次。如果超过一次，就意味着它们在函数中承担了一个以上的责任。</li></ul><h1 id="Remove-Assignments-to-Parameters（移除对参数的赋值）"><a href="#Remove-Assignments-to-Parameters（移除对参数的赋值）" class="headerlink" title="Remove Assignments to Parameters（移除对参数的赋值）"></a>Remove Assignments to Parameters（移除对参数的赋值）</h1><blockquote><p>以一个临时变量取代该参数的位置</p></blockquote><pre><code class="java">int discount (int inputVal, int quantity , int yearToDate) &#123;    if (inputVal &gt; 50 ) input -= 2;</code></pre><pre><code class="java">int discount(int inputVal,int quantity,int yearToDate) &#123;    int result = inputVal;    if (inputVal &gt; 50 ) result -= 2;</code></pre><h2 id="动机-6"><a href="#动机-6" class="headerlink" title="动机"></a>动机</h2><ul><li>这样的做法，降低了代码的清晰度，而且混用了按值传递和按引用传递这两种参数传递方式</li></ul><h1 id="Replace-Method-with-Method-Object-（以函数对象取代函数）"><a href="#Replace-Method-with-Method-Object-（以函数对象取代函数）" class="headerlink" title="Replace Method with Method Object （以函数对象取代函数）"></a>Replace Method with Method Object （以函数对象取代函数）</h1><blockquote><p>将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段</p></blockquote><pre><code class="java">class Order &#123;    double price() &#123;        double primaryBasePrice;        double secondaryBasePrice;        double tertiaryBasePrice;    &#125;&#125;</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/../img/replaceMethodWithMethodObj.png" alt="replaceMethodWithMethodObj"></h2><h2 id="动机-7"><a href="#动机-7" class="headerlink" title="动机"></a>动机</h2><ul><li>局部变量的存在会增加函数分解难度</li><li>无法用Replace Temp with Query 拆解一个需要拆解的函数</li></ul><h1 id="Substitute-Algorithm-（替换算法）"><a href="#Substitute-Algorithm-（替换算法）" class="headerlink" title="Substitute Algorithm （替换算法）"></a>Substitute Algorithm （替换算法）</h1><blockquote><p>将函数本体替换为另一个算法</p></blockquote><pre><code class="java">String foundPerson(String[] people)&#123;    for (int i =0; i &lt;people.length;i++)&#123;        if (people[0].equals(&quot;Don&quot;))&#123;            return &quot;Don&quot;;        &#125;    &#125;    return &quot;&quot;;&#125;</code></pre><pre><code class="java">String foundPerson(String[] people)&#123;    List candidates = Arrays.asList(new String[]&#123;&quot;Don&quot;,&quot;John&quot;&#125;);    for (int i =0; i &lt;people.length;i++)&#123;        if (candidates.contains(people[i]))&#123;            return people[i];        &#125;    &#125;    return &quot;&quot;;&#125;</code></pre><h2 id="动机-8"><a href="#动机-8" class="headerlink" title="动机"></a>动机</h2><ul><li>在原先的做法之外，有更简单的解决方案。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步-自旋锁</title>
      <link href="/2022/11/24/%E5%90%8C%E6%AD%A5-%E8%87%AA%E6%97%8B%E9%94%81/"/>
      <url>/2022/11/24/%E5%90%8C%E6%AD%A5-%E8%87%AA%E6%97%8B%E9%94%81/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> 同步 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
